<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consolidar Excel Automatizado</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Librerías Necesarias -->
    <!-- JSZip para manejar archivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- SheetJS (xlsx) para manipular Excel -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <!-- FontAwesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Colores Institucionales */
        :root {
            --primary-color: #9C2348; /* Guinda */
            --secondary-color: #A6802D; /* Dorado */
            --accent-color: #1E5B4F; /* Verde Oscuro */
            --success-color: #10B981; /* Verde Claro */
            --danger-color: #EF4444; /* Rojo */
        }
        .step-card {
            transition: all 0.3s ease;
        }
        .step-card.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(100%);
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal-backdrop {
            transition: opacity 0.3s ease;
        }
        .modal-content {
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        /* Estilos para Pestañas */
        .tab-btn.active {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            color: white;
        }
        .tab-content {
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        /* Estilos para KPI Cards */
        .kpi-card-detail {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .kpi-card-detail.open {
            max-height: 500px; /* Adjust as needed */
        }


    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans">

    <!-- Instructions Modal -->
    <div id="instructionsModal" class="hidden fixed inset-0 z-50">
        <!-- Backdrop -->
        <div onclick="toggleInstructions()" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50"></div>
        <!-- Modal Content -->
        <div class="modal-content relative bg-white rounded-lg shadow-xl p-8 m-4 max-w-lg mx-auto mt-20 border-t-4 border-[#A6802D]">
            <h2 class="font-bold text-2xl mb-4 text-[#A6802D]"><i class="fa-solid fa-circle-info mr-2"></i>Información</h2>
            <ol class="list-decimal list-inside text-gray-700 space-y-2">
                <li>Herramienta elaborada por <strong>José Cruz Gómez Rodríguez</strong></li>
                <li>Correo electrónico: <strong>josluigomez@gmail.com</strong></li>
                <li><strong>DC-620-2025</strong></li>
            </ol>
            <button onclick="toggleInstructions()" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
        </div>
    </div>

    <!-- PCUM Info Modal -->
    <div id="pcumInfoModal" class="hidden fixed inset-0 z-50">
        <!-- Backdrop -->
        <div onclick="togglePcumInfoModal()" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50"></div>
        <!-- Modal Content -->
        <div class="modal-content relative bg-white rounded-lg shadow-xl p-8 m-4 max-w-lg mx-auto mt-20 border-t-4 border-[#A6802D]">
            <h2 class="font-bold text-2xl mb-4 text-[#A6802D]"><i class="fa-solid fa-circle-info mr-2"></i>Metodología de Cálculo PCUM</h2>
            <p class="text-gray-700 space-y-2 mb-6">
                La metodología usada para el cálculo se establece en el proyecto de Metodología de Evaluación de la Gestión Gubernamental 2023.
            </p>
            <button onclick="downloadPcumMethodology()" class="bg-[#1E5B4F] text-white px-4 py-2 rounded hover:bg-opacity-90 transition flex items-center gap-2">
                <i class="fa-solid fa-download"></i>
                <span>Descargar Metodología</span>
            </button>
            <button onclick="togglePcumInfoModal()" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
        </div>
    </div>

    <!-- Steps Modal -->
    <div id="stepsModal" class="hidden fixed inset-0 z-50">
        <!-- Backdrop -->
        <div onclick="toggleStepsModal()" class="modal-backdrop fixed inset-0 bg-black bg-opacity-50"></div>
        <!-- Modal Content -->
        <div class="modal-content relative bg-gray-100 rounded-lg shadow-xl p-8 m-4 max-w-7xl w-full mx-auto mt-10">
            <div class="flex justify-between items-center mb-6">
                <h2 class="font-bold text-2xl text-[#9C2348]">Procesamiento Manual por Pasos</h2>
                <button onclick="toggleStepsModal()" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <!-- Processing Steps (Wizard) -->
            <div id="processingSteps" class="hidden grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-7 gap-4">
                <!-- Step 1 -->
                <div id="cardStep1" class="step-card bg-white p-4 rounded-lg shadow border-l-4 border-[#9C2348]">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 1</h3>
                        <span class="text-xs bg-red-100 text-[#9C2348] px-2 py-1 rounded">Consolidar Libros</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Une todos los archivos del ZIP en un solo libro de Excel.</p>
                    <button onclick="runStep1()" class="w-full bg-[#9C2348] text-white py-2 rounded hover:bg-opacity-90 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep1" onclick="downloadStep(1)" class="hidden mt-2 w-full border border-[#9C2348] text-[#9C2348] py-1 rounded hover:bg-red-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 2 -->
                <div id="cardStep2" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-teal-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 2</h3>
                        <span class="text-xs bg-teal-100 text-teal-800 px-2 py-1 rounded">Formato Relacional</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Limpia y transforma hojas (no "Ramo") a formato relacional.</p>
                    <button onclick="runStep2()" class="w-full bg-teal-600 text-white py-2 rounded hover:bg-teal-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep2" onclick="downloadStep(2)" class="hidden mt-2 w-full border border-teal-600 text-teal-600 py-1 rounded hover:bg-teal-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 3 -->
                <div id="cardStep3" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-indigo-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 3</h3>
                        <span class="text-xs bg-indigo-100 text-indigo-800 px-2 py-1 rounded">Extraer Datos</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Extrae Eje, Programa, Objetivo y Clasificación Funcional.</p>
                    <button onclick="runStep3()" class="w-full bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep3" onclick="downloadStep(3)" class="hidden mt-2 w-full border border-indigo-600 text-indigo-600 py-1 rounded hover:bg-indigo-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 3.1 -->
                <div id="cardStep3_1" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-cyan-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 3.1</h3>
                        <span class="text-xs bg-cyan-100 text-cyan-800 px-2 py-1 rounded">Limpiar "Ramo"</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Limpia, recorta y rellena las hojas cuyo nombre empieza con "Ramo".</p>
                    <button onclick="runStep3_1()" class="w-full bg-cyan-600 text-white py-2 rounded hover:bg-cyan-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep3_1" onclick="downloadStep('3.1')" class="hidden mt-2 w-full border border-cyan-600 text-cyan-600 py-1 rounded hover:bg-cyan-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 4 -->
                <div id="cardStep4" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-purple-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 4</h3>
                        <span class="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">Unificar Hojas</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Une todas las hojas en dos grupos: Ramo y General.</p>
                    <button onclick="runStep4()" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep4" onclick="downloadStep(4)" class="hidden mt-2 w-full border border-purple-600 text-purple-600 py-1 rounded hover:bg-purple-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 5 -->
                <div id="cardStep5" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-orange-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 5</h3>
                        <span class="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">Descombinar</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Elimina celdas combinadas en la hoja consolidada.</p>
                    <button onclick="runStep5()" class="hidden w-full bg-orange-600 text-white py-2 rounded hover:bg-orange-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep5" onclick="downloadStep(5)" class="hidden mt-2 w-full border border-orange-600 text-orange-600 py-1 rounded hover:bg-orange-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar
                    </button>
                </div>

                <!-- Step 6 -->
                <div id="cardStep6" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-green-500">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg">Paso 6</h3>
                        <span class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Rellenar Vacíos</span>
                    </div>
                    <p class="text-sm text-gray-600 mb-4">Rellena celdas vacías en Columnas A-F con el valor superior.</p>
                    <button onclick="runStep6()" class="hidden w-full bg-green-600 text-white py-2 rounded hover:bg-green-700 transition flex justify-center items-center gap-2">
                        <span>Ejecutar</span>
                    </button>
                    <button id="dlStep6" onclick="downloadStep(6)" class="hidden mt-2 w-full border border-green-600 text-green-600 py-1 rounded hover:bg-green-50 text-sm">
                        <i class="fa-solid fa-download"></i> Descargar Final
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8 max-w-6xl">

        <!-- Header -->
        <header class="mb-10 text-center flex flex-col items-center">
            <img src="https://github.com/SAGB-JCM/EMIR_BASE/blob/main/Gemini_Generated_Image_gfdjv0gfdjv0gfdj.png?raw=true" 
                alt="Logo" class="w-24 h-24 mb-4 rounded-md shadow-lg">

            <h1 class="text-4xl font-bold text-[#9C2348] mb-4">
                Evaluación de la Gestión Gubernamental 2024 (EEG)
            </h1>

            <p class="text-gray-600 max-w-3xl text-justify">
                Herramienta diseñada para facilitar el cálculo, análisis y validación de los
                indicadores Porcentaje de Cumplimiento de Metas de Desempeño (PCUM) 2024 y
                Desempeño de la Entrega de Productos de los Programas Presupuestarios en los
                que participa el Ente Público (DPP) 2024, mediante la extracción y
                procesamiento automatizado de metadatos provenientes de la información
                oficial publicada en la Cuenta Pública y en el Portal de Transparencia
                Presupuestaria. Su propósito es apoyar la evaluación objetiva del avance en
                metas, resultados y productos institucionales, fortaleciendo la rendición
                de cuentas y el seguimiento del desempeño gubernamental.
            </p>
        </header>

        <!-- Tab Navigation -->
        <div class="mb-8">
            <div class="border-b border-gray-300">
                <nav class="flex -mb-px space-x-4" aria-label="Tabs">
                    <button onclick="switchTab(event, 'emir')" class="tab-btn active whitespace-nowrap py-3 px-5 border-b-4 font-medium text-lg transition-colors duration-300">
                        <i class="fa-solid fa-gears mr-2"></i>Consolidadar MIR
                    </button>
                    <button onclick="switchTab(event, 'reports')" class="tab-btn whitespace-nowrap py-3 px-5 border-b-4 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-400 font-medium text-lg transition-colors duration-300">
                        <i class="fa-solid fa-chart-pie mr-2"></i>Reportes
                    </button>
                </nav>
            </div>
        </div>

        <!-- Tab Content -->
        <div id="emir" class="tab-content">

        <!-- Info Button -->
        <div class="relative mb-8">
            <button onclick="toggleInstructions()" class="absolute -top-20 right-0 bg-blue-100 text-blue-800 p-3 rounded-full shadow-md hover:bg-blue-200 transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-blue-500" title="Mostrar Instrucciones">
                <i class="fa-solid fa-circle-info text-2xl"></i>
            </button>
        </div>
        
        <!-- Input Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <!-- Parte 1: Descargar de Hacienda -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50 text-center">
                    <i class="fa-solid fa-cloud-arrow-down text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Paso 1: Obtener el archivo</h3>
                    <p class="text-sm text-gray-600 mb-4">Seleccione el año y descargue el archivo ZIP oficial de la Cuenta Pública.</p>
                    <div class="flex gap-2 justify-center">
                        <select id="yearSelector" class="border border-gray-300 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-[#1E5B4F]">
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                        </select>
                        <button onclick="openDownloadLink()" class="bg-[#1E5B4F] text-white px-4 py-2 rounded hover:bg-opacity-90 transition flex items-center gap-2">
                            <i class="fa-solid fa-download"></i>
                            <span>Descargar ZIP de Hacienda</span>
                        </button>
                    </div>
                </div>

                <!-- Parte 2: Subir ZIP Local -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-[#9C2348] transition-colors h-full flex flex-col justify-center">
                     <i class="fa-solid fa-upload text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Paso 2: Cargar el archivo</h3>
                    <p class="text-sm text-gray-600 mb-4">Una vez descargado, súbalo aquí para comenzar el procesamiento.</p>
                    <input type="file" id="fileInput" accept=".zip" class="hidden" onchange="handleFileUpload(this)">
                    <label for="fileInput" class="cursor-pointer bg-[#9C2348] text-white px-4 py-2 rounded hover:bg-opacity-90 transition">
                        Seleccionar Archivo .zip
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Input Section for Indicadores -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <!-- Parte 3: Descargar Indicadores -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50 text-center">
                    <i class="fa-solid fa-cloud-arrow-down text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Paso 3: Obtener Archivo de Indicadores</h3>
                    <p class="text-sm text-gray-600 mb-4">Descargue el archivo CSV con el avance de indicadores del año seleccionado.</p>
                    <button onclick="openIndicadoresDownloadLink()" class="bg-[#1E5B4F] text-white px-4 py-2 rounded hover:bg-opacity-90 transition flex items-center gap-2 mx-auto">
                        <i class="fa-solid fa-download"></i>
                        <span>Descargar CSV de Indicadores</span>
                    </button>
                </div>

                <!-- Parte 4: Subir CSV Local -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-[#9C2348] transition-colors h-full flex flex-col justify-center">
                     <i class="fa-solid fa-upload text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Paso 4: Cargar Archivo de Indicadores</h3>
                    <p class="text-sm text-gray-600 mb-4">Una vez descargado, súbalo aquí para su futuro uso.</p>
                    <input type="file" id="indicadoresFileInput" accept=".csv" class="hidden" onchange="handleIndicadoresFileUpload(this)">
                    <label for="indicadoresFileInput" class="cursor-pointer bg-[#9C2348] text-white px-4 py-2 rounded hover:bg-opacity-90 transition">
                        Seleccionar Archivo .csv
                    </label>
                </div>
            </div>
        </div>

        <!-- Log & Status Area -->
        <div id="statusArea" class="hidden bg-gray-900 text-green-400 font-mono text-sm p-4 rounded-lg mb-8 h-48 overflow-y-auto shadow-inner">
            <div id="logContent">Esperando archivo...</div>
        </div>

        <!-- Indicadores Status Area -->
        <div id="indicadoresStatusArea" class="hidden bg-gray-900 text-blue-300 font-mono text-sm p-4 rounded-lg mb-8 h-32 overflow-y-auto shadow-inner">
            <div id="indicadoresLogContent">Esperando archivo de indicadores...</div>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="hidden mb-8">
            <h2 class="text-xl font-bold mb-4">Contenido del ZIP</h2>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="min-w-full">
                    <thead class="bg-gray-200 text-gray-700">
                        <tr>
                            <th class="py-2 px-4 text-left">Archivo</th>
                            <th class="py-2 px-4 text-left">Hojas Detectadas</th>
                            <th class="py-2 px-4 text-left">Estado</th>
                        </tr>
                    </thead>
                    <tbody id="fileListBody" class="text-sm">
                        <!-- Rows injected here -->
                    </tbody>
                </table>
            </div>
            <div class="mt-2 text-right text-sm text-gray-500">
                Total archivos Excel encontrados: <span id="totalFilesCount" class="font-bold">0</span>
            </div>
        </div>

        <!-- All-in-One Step -->
        <div id="allInOneStep" class="hidden bg-white rounded-lg shadow-lg p-6 mb-8 border-t-4 border-[#9C2348]">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div>
                    <h2 class="text-xl font-bold text-[#9C2348]">Paso Final - Consolidar Base de Datos MIR-Indicadores</h2>
                    <p class="text-gray-600 text-sm mt-1 text-justify">
                        Este paso consolida la información reportada en la Matriz de Indicadores para Resultados (MIR) de la Cuenta Pública y en el Programa de Avance de Indicadores del Portal de Transparencia Presupuestaria, con el propósito de identificar, analizar y contrastar posibles diferencias en los programas, indicadores, metas y niveles de avance reportados. El archivo descargado puede ser revisado de manera manual; para la consulta y análisis de los indicadores consolidados, utilice la pestaña correspondiente de indicadores.
                    </p>
                </div>
                <div class="flex flex-col items-center gap-2 w-full md:w-auto">
                    <button id="runAllBtn" onclick="runAllSteps()" class="w-full md:w-auto bg-[#9C2348] text-white px-6 py-3 rounded-lg hover:bg-opacity-90 transition-transform transform hover:scale-105 flex justify-center items-center gap-2 font-bold shadow-md hover:shadow-lg">
                        <i class="fa-solid fa-rocket"></i>
                        <span>Ejecutar Todo y Descargar</span>
                    </button>
                    <button id="showStepsBtn" onclick="toggleStepsModal()" class="hidden text-sm text-blue-600 hover:underline">Ver Pasos Individuales</button>
                </div>
            </div>
        </div>

        </div>

        <div id="reports" class="tab-content hidden">
            <!-- Report Input Section -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                    <!-- Opción 1: Usar resultado del consolidador -->
                    <div class="border border-gray-200 rounded-lg p-6 bg-gray-50 text-center">
                        <i class="fa-solid fa-wand-magic-sparkles text-4xl text-gray-400 mb-4"></i>
                        <h3 class="font-bold mb-2">Opción 1: Usar Resultado del Consolidador</h3>
                        <p class="text-sm text-gray-600 mb-4">Analiza directamente el archivo final generado en la pestaña anterior.</p>
                        <button id="useProcessedFileBtn" onclick="generateReportsFromState()" class="bg-[#1E5B4F] text-white px-4 py-2 rounded hover:bg-opacity-90 transition flex items-center gap-2 mx-auto">
                            <i class="fa-solid fa-play"></i>
                            <span>Generar Reportes</span>
                        </button>
                    </div>

                    <!-- Opción 2: Cargar archivo modificado -->
                    <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-[#9C2348] transition-colors h-full flex flex-col justify-center">
                         <i class="fa-solid fa-file-excel text-4xl text-gray-400 mb-4"></i>
                        <h3 class="font-bold mb-2">Opción 2: Cargar Archivo Modificado</h3>
                        <p class="text-sm text-gray-600 mb-4">Sube un archivo consolidado (XLSX) si has realizado cambios manuales.</p>
                        <input type="file" id="reportFileInput" accept=".xlsx" class="hidden" onchange="generateReportsFromFile(this)">
                        <label for="reportFileInput" class="cursor-pointer bg-[#9C2348] text-white px-4 py-2 rounded hover:bg-opacity-90 transition">
                            Seleccionar Archivo .xlsx
                        </label>
                    </div>
                </div>
            </div>

            <!-- Report Display Area -->
            <div id="reportDisplayArea" class="hidden">
                <h2 class="text-2xl font-bold text-gray-700 mb-6">Métricas Principales</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- KPI 1: Programas Presupuestarios -->
                    <div id="kpiCard1" class="bg-white rounded-lg shadow-lg overflow-hidden cursor-pointer" onclick="toggleKpiDetail('kpiDetail1')">
                        <div class="p-5">
                            <p class="text-sm text-gray-500 uppercase">Programas Presupuestarios</p>
                            <p id="kpiTotalProgramas" class="text-4xl font-bold text-[#9C2348]">0</p>
                            <p class="text-xs text-gray-400">Total de programas únicos (clic para ver listado)</p>
                        </div>
                        <div id="kpiDetail1" class="kpi-card-detail bg-gray-50 border-t border-gray-200 px-5 py-3">
                            <h4 class="font-bold text-sm mb-2 text-gray-600">Ver Programas</h4>
                            <ul id="kpiProgramasPorRamo" class="text-sm text-gray-700 space-y-1 max-h-48 overflow-y-auto"></ul>
                        </div>
                    </div>
                    <!-- KPI 3: Indicadores por Programa -->
                    <div id="kpiCard3" class="bg-white rounded-lg shadow-lg overflow-hidden cursor-pointer" onclick="toggleKpiDetail('kpiDetail3')">
                        <div class="p-5">
                            <p class="text-sm text-gray-500 uppercase">Indicadores por Programa Presupuestario</p>
                            <p id="kpiFrecuenciaProgramas" class="text-4xl font-bold text-[#A6802D]">0</p>
                            <p class="text-xs text-gray-400">Total de indicadores por progrma (clic para ver desglose)</p>
                        </div>
                        <div id="kpiDetail3" class="kpi-card-detail bg-gray-50 border-t border-gray-200 px-5 py-3">
                            <h4 class="font-bold text-sm mb-2 text-gray-600">Desglose por Programa</h4>
                            <ul id="kpiDesgloseProgramas" class="text-sm text-gray-700 space-y-1 max-h-48 overflow-y-auto"></ul>
                        </div>
                    </div>
                    <!-- KPI 2: Indicadores por Ramo -->
                    <div id="kpiCard2" class="bg-white rounded-lg shadow-lg overflow-hidden cursor-pointer" onclick="toggleKpiDetail('kpiDetail2')">
                        <div class="p-5">
                            <p class="text-sm text-gray-500 uppercase">Indicadores por Ramo</p>
                            <p id="kpiFrecuenciaRamos" class="text-4xl font-bold text-[#1E5B4F]">0</p>
                            <p class="text-xs text-gray-400">Total de indicadores por Ramo (clic para ver desglose)</p>
                        </div>
                        <div id="kpiDetail2" class="kpi-card-detail bg-gray-50 border-t border-gray-200 px-5 py-3">
                            <h4 class="font-bold text-sm mb-2 text-gray-600">Desglose por Ramo</h4>
                            <ul id="kpiDesgloseRamos" class="text-sm text-gray-700 space-y-1 max-h-48 overflow-y-auto"></ul>
                        </div>
                    </div>
                </div>
                <!-- KPI 4: PCUM (movido a una nueva fila para destacarlo) -->
                <div id="kpiCard4" class="lg:col-span-3 bg-white rounded-lg shadow-lg overflow-hidden cursor-pointer transition-all duration-300" onclick="toggleKpiDetail('kpiDetail4')">
                    <div class="p-5">
                        <div class="flex justify-between items-start">
                            <div>
                                <p class="text-sm text-gray-500 uppercase flex items-center">
                                    Promedio PCUM General
                                    <i onclick="event.stopPropagation(); togglePcumInfoModal();" class="fa-solid fa-circle-info text-blue-500 ml-2 cursor-pointer hover:text-blue-700" title="Ver metodología de cálculo"></i>
                                </p>
                                <p id="kpiPromedioPcum" class="text-4xl font-bold">0.00</p>
                            </div>
                             <span id="pcumStatus" class="text-sm font-bold px-3 py-1 rounded-full"></span>
                        </div>
                        <p class="text-xs text-gray-400 mt-1">Promedio del Puntaje de Cumplimiento (clic para ver desglose)</p>
                    </div>
                    <div id="kpiDetail4" class="kpi-card-detail bg-gray-50 border-t border-gray-200 px-5 py-3">
                        <h4 class="font-bold text-sm mb-2 text-gray-600">PCUM por Ramo</h4>
                        <ul id="kpiPcumPorRamo" class="text-sm text-gray-700 space-y-1 max-h-48 overflow-y-auto"></ul>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- MAIN LOGIC SCRIPT -->
    <script>
        // === STATE MANAGEMENT ===
        const STATE = {
            zipFiles: [], // Array of objects { name, data (arraybuffer) }
            fidMarkedSheetNames: new Set(), // Set to store unique names of sheets to be marked as FID
            wbStep1: null, // The workbook object after Step 1
            wbStep2: null, // The workbook object after Step 2
            wbStep3: null, // The workbook object after Step 3,
            wbStep3_1: null, // The workbook object after Step 3.1
            wbStep4: null, // The workbook object after Step 4
            wbStep5: null, // The workbook object after Step 5
            wbStep6: null, // The workbook object after Step 6
            reportData: [], // Array of objects for the report tab
            indicadoresData: null // Data from the uploaded indicadores CSV
        };

        // === LOGGING UTILS ===
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('logContent');
            const color = type === 'error' ? 'text-red-500' : (type === 'success' ? 'text-green-300' : 'text-green-400');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div class="${color}">[${time}] ${msg}</div>`;
            document.getElementById('statusArea').scrollTop = document.getElementById('statusArea').scrollHeight;
        }

        // === UI UTILS ===
        function toggleInstructions() {
            const modal = document.getElementById('instructionsModal');
            modal.classList.toggle('hidden');
        }

        function togglePcumInfoModal() {
            const modal = document.getElementById('pcumInfoModal');
            modal.classList.toggle('hidden');
        }

        function downloadPcumMethodology() {
            const url = 'https://www.gob.mx/buengobierno/documentos/evaluacion-de-la-gestion-gubernamental-2023?state=published';
            window.open(url, '_blank');
        }

        // === TAB SWITCHING LOGIC ===
        function switchTab(event, tabName) {
            // Ocultar todos los contenidos de las pestañas
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.add('hidden');
            });

            // Quitar la clase 'active' de todos los botones de pestaña
            const tabButtons = document.querySelectorAll('.tab-btn');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Mostrar el contenido de la pestaña seleccionada y marcar el botón como activo
            document.getElementById(tabName).classList.remove('hidden');
            event.currentTarget.classList.add('active');
        }

        function toggleStepsModal() {
            const modal = document.getElementById('stepsModal');
            const stepsContainer = document.getElementById('processingSteps');
            stepsContainer.classList.remove('hidden'); // Asegurarse de que los pasos sean visibles
            modal.classList.toggle('hidden');
        }

        // === REPORTING LOGIC ===
        function toggleKpiDetail(detailId) {
            document.getElementById(detailId).classList.toggle('open');
        }

        async function generateReportsFromState() {
            log("Generando reportes desde el estado actual...", "info");
            const btn = document.getElementById('useProcessedFileBtn');
            btn.disabled = true;
            btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Cargando...`;

            // El resultado final está en wbStep4 después de la limpieza.
            if (!STATE.wbStep4 || !STATE.wbStep4.Sheets["CONSOLIDADO_TOTAL"]) {
                alert("No se encontró un archivo procesado. Por favor, ejecute el consolidador primero en la pestaña 'Consolidador EMIR'.");
                log("No se encontró el libro de trabajo final (STATE.wbStep4) para generar reportes.", "error");
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-play"></i><span> Generar Reportes</span>`;
                return;
            }

            // Se usa wbStep4 porque contiene el consolidado antes de la limpieza final de columnas.
            // La limpieza se aplica aquí para asegurar que los datos para el reporte tengan la misma estructura que el archivo final.
            const wbForReport = applyFinalCleanup(STATE.wbStep4);
            const ws = wbForReport.Sheets["CONSOLIDADO_TOTAL"];
            STATE.reportData = XLSX.utils.sheet_to_json(ws, { defval: "" });
            
            calculateAndDisplayKPIs();
            
            btn.disabled = false;
            btn.innerHTML = `<i class="fa-solid fa-play"></i><span> Generar de Nuevo</span>`;
        }

        async function generateReportsFromFile(input) {
            const file = input.files[0];
            if (!file) return;

            log(`Cargando archivo de reporte: ${file.name}`, "info");
            const data = await file.arrayBuffer();
            const wb = XLSX.read(data);
            
            // Asumimos que la hoja de interés es la primera
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            STATE.reportData = XLSX.utils.sheet_to_json(ws);

            calculateAndDisplayKPIs();
        }

        function calculateAndDisplayKPIs() {
            if (STATE.reportData.length === 0) {
                alert("El archivo no contiene datos o no se pudo leer correctamente.");
                return;
            }

            document.getElementById('reportDisplayArea').classList.remove('hidden');
            log("Calculando KPIs...", "info");

            // Column names based on your final output
            const COL_PROG_PRESUP = "Programa Presupuestario"; // Col F
            const COL_RAMO = "Ramo"; // Col G
            const COL_INDICADOR = "DENOMINACIÓN"; // Col A
            const COL_AVANCE_PCT = "Avance %";

            // --- Añadir columnas calculadas para PCUM al reportData ---
            const dataWithPcum = addPcumColumnsToData(STATE.reportData);

            // --- KPI 1: Programas Presupuestarios Únicos y desglose por Ramo ---
            const programasUnicos = new Set();
            const frecuenciaPorRamo = {}; // { 'Ramo1': 10, 'Ramo2': 5 }
            const frecuenciaPorPrograma = {}; // { 'ProgA': 20, 'ProgB': 15 }
            let totalFrecuenciaRamos = 0;
            let totalFrecuenciaProgramas = 0;
            let sumaPcumTotal = 0;
            let countPcumValidos = 0;
            const pcumPorRamo = {}; // { 'Ramo1': { sum: X, count: Y }, ... }

            dataWithPcum.forEach(row => {
                const programa = row[COL_PROG_PRESUP];
                const ramo = row[COL_RAMO];
                const pcum = row["PCUM"];
 
                // KPI 1: Contar programas únicos
                if (programa && String(programa).trim() !== '') {
                    programasUnicos.add(programa);
                }

                // KPI 2: Contar frecuencia por Ramo
                if (ramo && String(ramo).trim() !== '') {
                    frecuenciaPorRamo[ramo] = (frecuenciaPorRamo[ramo] || 0) + 1;
                    totalFrecuenciaRamos++;
                }

                // KPI 3: Contar frecuencia por Programa Presupuestario
                if (programa && String(programa).trim() !== '') {
                    frecuenciaPorPrograma[programa] = (frecuenciaPorPrograma[programa] || 0) + 1;
                    totalFrecuenciaProgramas++;
                }

                // KPI 4: Acumular PCUM
                if (typeof pcum === 'number') {
                    sumaPcumTotal += pcum;
                    countPcumValidos++;
                    if (ramo && String(ramo).trim() !== '') {
                        if (!pcumPorRamo[ramo]) pcumPorRamo[ramo] = { sum: 0, count: 0 };
                        pcumPorRamo[ramo].sum += pcum;
                        pcumPorRamo[ramo].count++;
                    }
                }
            });

            // --- Rellenar KPI 1 (Programas Únicos) ---
            document.getElementById('kpiTotalProgramas').textContent = programasUnicos.size;
            
            const kpiProgramasPorRamoList = document.getElementById('kpiProgramasPorRamo');
            kpiProgramasPorRamoList.innerHTML = '';
            // Convertir el Set a un array, ordenarlo y mostrarlo.
            const programasArray = Array.from(programasUnicos).sort();
            programasArray.forEach(programa => {
                const li = document.createElement('li');
                li.textContent = programa;
                kpiProgramasPorRamoList.appendChild(li);
            });

            // --- Rellenar KPI 2 (Frecuencia por Ramo) ---
            document.getElementById('kpiFrecuenciaRamos').textContent = totalFrecuenciaRamos;
            const kpiDesgloseRamosList = document.getElementById('kpiDesgloseRamos');
            kpiDesgloseRamosList.innerHTML = '';
            // Ordenar ramos por cantidad de indicadores (mayor a menor)
            Object.entries(frecuenciaPorRamo)
                .sort(([, a], [, b]) => b - a) // Ordena por valor (conteo) descendente
                .forEach(([ramo, count]) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="font-semibold">${ramo}:</span> ${count} indicadores`;
                    kpiDesgloseRamosList.appendChild(li);
                });

            // --- Rellenar KPI 3 (Frecuencia por Programa) ---
            document.getElementById('kpiFrecuenciaProgramas').textContent = totalFrecuenciaProgramas;
            const kpiDesgloseProgramasList = document.getElementById('kpiDesgloseProgramas');
            kpiDesgloseProgramasList.innerHTML = '';
            // Ordenar programas por cantidad de indicadores (mayor a menor)
            Object.entries(frecuenciaPorPrograma)
                .sort(([, a], [, b]) => b - a) // Ordena por valor (conteo) descendente
                .forEach(([programa, count]) => {
                    const li = document.createElement('li');
                    const displayName = programa.length > 40 ? programa.substring(0, 37) + '...' : programa;
                    li.innerHTML = `<span class="font-semibold" title="${programa}">${displayName}:</span> ${count} indicadores`;
                    kpiDesgloseProgramasList.appendChild(li);
                });

            // --- Rellenar KPI 4 (PCUM) ---
            const promedioPcum = countPcumValidos > 0 ? (sumaPcumTotal / countPcumValidos) : 0;
            const kpiPcumElement = document.getElementById('kpiPromedioPcum');
            const kpiCard4 = document.getElementById('kpiCard4');
            const pcumStatus = document.getElementById('pcumStatus');

            kpiPcumElement.textContent = promedioPcum.toFixed(2);

            // Lógica de colores y etiquetas para PCUM
            kpiCard4.classList.remove('border-green-500', 'border-yellow-500', 'border-red-500', 'bg-green-50', 'bg-yellow-50', 'bg-red-50');
            if (promedioPcum >= 70) {
                kpiCard4.classList.add('border-l-4', 'border-green-500');
                pcumStatus.textContent = 'Adecuado';
                pcumStatus.className = 'text-sm font-bold px-3 py-1 rounded-full bg-green-100 text-green-800';
            } else if (promedioPcum >= 50) {
                kpiCard4.classList.add('border-l-4', 'border-yellow-500');
                pcumStatus.textContent = 'Regular';
                pcumStatus.className = 'text-sm font-bold px-3 py-1 rounded-full bg-yellow-100 text-yellow-800';
            } else {
                kpiCard4.classList.add('border-l-4', 'border-red-500');
                pcumStatus.textContent = 'Deficiente';
                pcumStatus.className = 'text-sm font-bold px-3 py-1 rounded-full bg-red-100 text-red-800';
            }

            const kpiPcumPorRamoList = document.getElementById('kpiPcumPorRamo');
            kpiPcumPorRamoList.innerHTML = '';
            Object.entries(pcumPorRamo)
                .map(([ramo, data]) => ({ ramo, avg: data.sum / data.count }))
                .sort((a, b) => b.avg - a.avg) // Ordenar por promedio PCUM descendente
                .forEach(({ ramo, avg }) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="font-semibold">${ramo}:</span> ${avg.toFixed(2)}`;
                    kpiPcumPorRamoList.appendChild(li);
                });



            log("KPIs mostrados.", "success");
        }

        // === FILE HANDLING ===
        async function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            processZip(file);
        }

        function openDownloadLink() {
            const year = document.getElementById('yearSelector').value;
            if (!year) {
                log("Por favor, seleccione un año.", "error");
                return;
            }
            const url = `https://www.cuentapublica.hacienda.gob.mx/work/models/CP/${year}/tomo/III/E_MIR.zip`;
            log(`Abriendo enlace de descarga para el año ${year} en una nueva pestaña...`);
            window.open(url, '_blank');
        }

        function openIndicadoresDownloadLink() {
            const year = document.getElementById('yearSelector').value;
            if (!year) {
                log("Por favor, seleccione un año.", "error");
                return;
            }
            const url = `https://nptp.hacienda.gob.mx/programas/DownloadServlet?fileName=/WbasketNPTP/programas/DescargaIndicadores/prog_avance_de_indicadores_${year}.csv`;
            log(`Abriendo enlace de descarga de indicadores para el año ${year}...`, 'info');
            window.open(url, '_blank');
        }

        async function handleIndicadoresFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const statusArea = document.getElementById('indicadoresStatusArea');
            const logContent = document.getElementById('indicadoresLogContent');
            statusArea.classList.remove('hidden');
            logContent.innerHTML = `<div class="text-yellow-300">Cargando archivo ${file.name}...</div>`;

            try {
                const text = await file.text();
                // Usamos PapaParse (incluido en SheetJS) para parsear el CSV de forma robusta
                const result = XLSX.utils.sheet_to_json(XLSX.read(text, {type: 'string'}).Sheets.Sheet1, {header: 1});
                
                STATE.indicadoresData = result;

                const rowCount = result.length;
                const colCount = rowCount > 0 ? result[0].length : 0;

                logContent.innerHTML = `<div class="text-green-300">Archivo cargado: ${file.name}</div>`;
                logContent.innerHTML += `<div><span class="font-bold">Renglones:</span> ${rowCount}</div>`;
                logContent.innerHTML += `<div><span class="font-bold">Columnas:</span> ${colCount}</div>`;
                logContent.innerHTML += `<div><span class="font-bold">Listo para el paso Final</span></div>`;
            } catch (e) {
                logContent.innerHTML = `<div class="text-red-500">Error al procesar el archivo CSV: ${e.message}</div>`;
            }
        }

        async function processZip(blobOrFile) {
            document.getElementById('statusArea').classList.remove('hidden');
            document.getElementById('previewSection').classList.add('hidden');
            
            log("Abriendo archivo ZIP...");
            
            try {
                const zip = new JSZip();
                const contents = await zip.loadAsync(blobOrFile);
                
                STATE.zipFiles = [];
                const tableBody = document.getElementById('fileListBody');
                tableBody.innerHTML = '';
                let fileCount = 0;

                // Iterate through files in ZIP
                const promises = [];
                
                contents.forEach((relativePath, zipEntry) => {
                    // Filter for excel files, ignore MACOSX junk
                    if (!zipEntry.dir && !relativePath.includes('__MACOSX') && (relativePath.endsWith('.xls') || relativePath.endsWith('.xlsx'))) {
                        const p = zipEntry.async("arraybuffer").then(data => {
                            // Basic read to get sheet count without full parsing overhead if possible
                            // But SheetJS read is sync, so we wrap later.
                            STATE.zipFiles.push({
                                name: relativePath,
                                data: data,
                                fileNameSimple: relativePath.split('/').pop()
                            });
                        });
                        promises.push(p);
                    }
                });

                log(`Extrayendo ${promises.length} archivos Excel...`);
                await Promise.all(promises);

                STATE.zipFiles.forEach((file, index) => {
                    fileCount++;
                    const tr = document.createElement('tr');
                    tr.className = "border-b hover:bg-gray-50";
                    tr.innerHTML = `
                        <td class="py-2 px-4 truncate max-w-xs" title="${file.name}">${file.name}</td>
                        <td class="py-2 px-4 text-gray-500 italic">Pendiente de lectura</td>
                        <td class="py-2 px-4 text-yellow-600"><i class="fa-regular fa-clock"></i> Listo para procesar</td>
                    `;
                    tableBody.appendChild(tr);
                });

                document.getElementById('totalFilesCount').innerText = fileCount;
                
                if (fileCount > 0) {
                    document.getElementById('previewSection').classList.remove('hidden');
                    document.getElementById('allInOneStep').classList.remove('hidden');
                    document.getElementById('showStepsBtn').classList.remove('hidden');
                    log("ZIP procesado exitosamente. Listo para Paso 3.", 'success');
                } else {
                    log("No se encontraron archivos .xls o .xlsx válidos en el ZIP.", 'error');
                }

            } catch (e) {
                log("Error leyendo el ZIP: " + e.message, 'error');
            }
        }

        // === ALL-IN-ONE PROCESS ===
        async function runAllSteps() {
            const btn = document.getElementById('runAllBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Procesando...`;
            btn.disabled = true;

            try {
                log("--- INICIANDO PROCESO COMPLETO ---", "success");

                await runStep1();
                if (!STATE.wbStep1) throw new Error("El Paso 1 falló y detuvo el proceso.");

                await runStep2();
                if (!STATE.wbStep2) throw new Error("El Paso 2 falló y detuvo el proceso.");

                await runStep3();
                if (!STATE.wbStep3) throw new Error("El Paso 3 falló y detuvo el proceso.");

                await runStep3_1();
                if (!STATE.wbStep3_1) throw new Error("El Paso 3.1 falló y detuvo el proceso.");

                await runStep4();
                if (!STATE.wbStep4) throw new Error("El Paso 4 falló y detuvo el proceso.");

                log("--- PROCESO COMPLETO FINALIZADO ---", "success");
                log("Descargando archivo final...", "info");

                // Aplicar limpieza final antes de descargar
                log("Aplicando limpieza final (unificar columnas, eliminar vacías)...");
                const cleanedWb = applyFinalCleanup(STATE.wbStep4);

                log("Añadiendo columnas PCUM...");
                const pcumWb = addPcumColumnsToWorkbook(cleanedWb);

                log("Aplicando estilos finales...");
                const styledWb = applyStylesToWorkbook(pcumWb);
                XLSX.writeFile(styledWb, "EMIR_CONSOLIDADO_FINAL_PCUM.xlsx");

            } catch (error) {
                log(`Error en el proceso completo: ${error.message}`, 'error');
                log("El proceso se ha detenido. Revisa los logs para más detalles.", 'error');
            } finally {
                // Restaurar el botón
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        // === FINAL CLEANUP UTILITY ===
        function applyFinalCleanup(wb) {
            const sheetName = "CONSOLIDADO_TOTAL";
            const ws = wb.Sheets[sheetName];
            if (!ws) {
                log("Advertencia: No se encontró la hoja 'CONSOLIDADO_TOTAL' para la limpieza final.", "error");
                return wb;
            }

            let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

            if (data.length < 2) {
                log("Advertencia: La hoja 'CONSOLIDADO_TOTAL' no tiene datos suficientes para la limpieza final.", "error");
                return wb;
            }

            // Indices de columnas: H=7, W=22, Y=24, Z=25
            const COL_H_INDEX = 7;
            const COL_W_INDEX = 22;
            const COL_Y_INDEX = 24;
            const COL_Z_INDEX = 25;
            const PREFIX_TO_REMOVE = "Unidad Responsable*: ";

            // 1. Unificar columnas H y Y en Z
            data.forEach((row, index) => {
                if (index === 0) { // Fila de encabezado
                    row[COL_Z_INDEX] = "Unidad Responsable (Unificada)";
                    return;
                }

                const valH = row[COL_H_INDEX];
                const valY = row[COL_Y_INDEX];

                if (valH && String(valH).trim() !== '') {
                    row[COL_Z_INDEX] = valH;
                } else if (valY && String(valY).trim() !== '') {
                    row[COL_Z_INDEX] = String(valY).replace(PREFIX_TO_REMOVE, '').trim();
                } else {
                    row[COL_Z_INDEX] = null;
                }
            });

            // 2. Eliminar columnas W, Y, H (en orden inverso para no afectar los índices)
            data.forEach(row => {
                row.splice(COL_Y_INDEX, 1); // Eliminar Y
                row.splice(COL_W_INDEX, 1); // Eliminar W
                row.splice(COL_H_INDEX, 1); // Eliminar H
            });

            // 3. Crear un nuevo libro de trabajo con la hoja modificada
            const newWs = XLSX.utils.aoa_to_sheet(data);
            wb.Sheets[sheetName] = newWs;
            return wb;
        }

        // === PCUM CALCULATION UTILITY ===
        function addPcumColumnsToData(data) {
            const COL_AVANCE_PCT = "Avance %";
            const COL_META_APROBADA = "Meta Anual Aprobada";
            const COL_META_AJUSTADA = "Meta Anual Ajustada";
            const COL_UR_UNIFICADA = "Unidad Responsable (Unificada)";

            return data.map(row => {
                const newRow = { ...row };
                const avance = parseFloat(newRow[COL_AVANCE_PCT]);
                const metaAprobada = newRow[COL_META_APROBADA];
                const metaAjustada = newRow[COL_META_AJUSTADA];
                const ur = String(newRow[COL_UR_UNIFICADA] || '').trim();

                // --- Lógica para Dependencia/Entidad ---
                // Se ejecuta primero para asegurar que todas las filas tengan este valor.
                let tipoUR = "Entidad"; // Valor por defecto
                if (ur) {
                    const firstThreeChars = ur.substring(0, 3);
                    // Comprueba si los 3 caracteres son numéricos.
                    if (!isNaN(firstThreeChars) && !isNaN(parseFloat(firstThreeChars))) {
                        tipoUR = "Dependencia";
                    }
                }
                newRow["Tipo UR"] = tipoUR;

                let avanceAcotado;

                // --- Lógica de Avance Acotado, Penalización y PCUM ---
                const isMetaAjustadaCero = metaAjustada === 0 || metaAjustada === "0";
                const isMetaAjustadaInvalid = metaAjustada === "" || metaAjustada === null;
                const isMetaAprobadaInvalid = metaAprobada === "" || metaAprobada === null || metaAprobada === 0 || metaAprobada === "0";
                const isAvanceNotANumber = isNaN(avance) || newRow[COL_AVANCE_PCT] === "N/A" || newRow[COL_AVANCE_PCT] === "" || newRow[COL_AVANCE_PCT] === null;

                // CASO ESPECIAL: Si la meta ajustada es 0, todo es N/A.
                if (isMetaAjustadaCero) {
                    avanceAcotado = "N/A";
                    newRow["AVANCE ACOTADO"] = "N/A";
                    newRow["PENALIZACIÓN"] = "N/A";
                    newRow["PCUM"] = "N/A";
                    return newRow; // Salir temprano
                }

                if (isMetaAjustadaInvalid && isMetaAprobadaInvalid) { // Si ambas metas son inválidas
                    avanceAcotado = "N/A";
                } else if (isAvanceNotANumber) { // Si hay meta pero el avance es inválido (vacío, N/A, etc.)
                    avanceAcotado = 0; // Se considera como 0% de avance.
                } else if (avance > 100) {
                    avanceAcotado = 100;
                } else if (avance < 0) {
                    avanceAcotado = 0;
                } else {
                    avanceAcotado = avance;
                }
                newRow["AVANCE ACOTADO"] = avanceAcotado;

                // Lógica de Penalización
                let penalizacion;
                if (avanceAcotado === "N/A") { // La penalización depende del avance acotado
                    penalizacion = "N/A";
                } else if (isAvanceNotANumber || avance <= 0) { // Si es NaN, vacío, nulo, 0 o negativo
                    penalizacion = 0;
                } else {
                    if (avance > 300) penalizacion = -30;
                    else if (avance > 280) penalizacion = -27;
                    else if (avance > 260) penalizacion = -24;
                    else if (avance > 240) penalizacion = -21;
                    else if (avance > 220) penalizacion = -18;
                    else if (avance > 200) penalizacion = -15;
                    else if (avance > 180) penalizacion = -12;
                    else if (avance > 160) penalizacion = -9;
                    else if (avance > 140) penalizacion = -6;
                    else if (avance > 120) penalizacion = -3;
                    else if (avance >= 80) penalizacion = 0;
                    else penalizacion = -3;
                }
                newRow["PENALIZACIÓN"] = penalizacion;

                // Lógica de PCUM
                let pcum;
                if (avanceAcotado === "N/A" || penalizacion === "N/A") {
                    pcum = "N/A";
                } else {
                    pcum = avanceAcotado + penalizacion;
                }
                newRow["PCUM"] = pcum;

                return newRow;
            });
        }

        function addPcumColumnsToWorkbook(wb) {
            const sheetName = "CONSOLIDADO_TOTAL";
            const ws = wb.Sheets[sheetName];
            if (!ws) {
                log("Advertencia: No se encontró la hoja 'CONSOLIDADO_TOTAL' para añadir columnas PCUM.", "error");
                return wb;
            }

            let data = XLSX.utils.sheet_to_json(ws, { defval: "" });
            const dataWithPcum = addPcumColumnsToData(data);

            const newWs = XLSX.utils.json_to_sheet(dataWithPcum);
            wb.Sheets[sheetName] = newWs;

            return wb;
        }


        // === STEP 1: CONSOLIDATE WORKBOOKS ===
        async function runStep1() {
            setLoading(1, true);
            log("Iniciando Paso 1: Unificando todos los libros...");
            
            // Allow UI to render loader
            await new Promise(r => setTimeout(r, 100));

            try {
                // Create a new master workbook
                const masterWb = XLSX.utils.book_new();
                STATE.fidMarkedSheetNames.clear(); // Reset on each run
                const usedSheetNames = new Set();
                let filesProcessed = 0;
                let sheetsCopied = 0;

                for (const file of STATE.zipFiles) {
                    try {
                        // Read the excel file from buffer
                        const wb = XLSX.read(file.data, { type: 'array' });
                        let isAfterFidSheet = false;
                        
                        wb.SheetNames.forEach(sheetName => {
                            // REQUERIMIENTO: Usar hojas "FID" como marcador, pero no incluirlas.
                            if (sheetName.toUpperCase().startsWith('FID')) {
                                log(`Omitiendo hoja '${sheetName}' del archivo '${file.fileNameSimple}' porque empieza con 'FID'.`);
                                isAfterFidSheet = true; // Marcar que las siguientes hojas en este libro son FID
                                return; // Saltar esta hoja
                            }

                            let ws = wb.Sheets[sheetName];
                            
                            // Handle duplicate names (Requerimiento: "conservando su nombre original (no se repiten y debe verificar que no lo hagan)")
                            let uniqueName = sheetName;
                            let counter = 1;
                            while (usedSheetNames.has(uniqueName)) {
                                uniqueName = `${sheetName}_${counter}`;
                                counter++;
                            }
                            usedSheetNames.add(uniqueName);

                            // Si estamos después de una hoja FID en este libro, marcamos esta hoja.
                            if (isAfterFidSheet) {
                                STATE.fidMarkedSheetNames.add(uniqueName);
                            }

                            // Add to master workbook
                            XLSX.utils.book_append_sheet(masterWb, ws, uniqueName);
                            sheetsCopied++;
                        });
                        filesProcessed++;
                        // Log progress every 5 files to not spam
                        if (filesProcessed % 5 === 0) log(`Procesados ${filesProcessed}/${STATE.zipFiles.length} archivos...`);
                        
                    } catch (err) {
                        log(`Error leyendo ${file.name}: ${err.message}`, 'error');
                    }
                }

                STATE.wbStep1 = masterWb;
                
                log(`Paso 1 Completado. Libros: ${filesProcessed}, Hojas totales: ${sheetsCopied}`, 'success');
                setLoading(1, false);
                enableStep(2);
                document.getElementById('dlStep1').classList.remove('hidden');

            } catch (e) {
                log("Error crítico en Paso 1: " + e.message, 'error');
                setLoading(1, false);
            }
        }

        // === STEP 2: PRE-PROCESS SHEETS (THE NEW STEP 1.1) ===
        async function runStep2() {
            setLoading(2, true);
            log("Iniciando Paso 2: Pre-procesando hojas (limpieza y formato relacional)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep1) throw new Error("Falta el resultado del Paso 1");

                // Create a new workbook for the results of this step
                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of STATE.wbStep1.SheetNames) {
                    const ws = STATE.wbStep1.Sheets[sheetName];

                    if (sheetName.toLowerCase().startsWith('ramo')) {
                        // If sheet name starts with "Ramo", copy it as is
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        log(`Hoja '${sheetName}' omitida del pre-proceso (comienza con 'Ramo').`);
                        continue;
                    }

                    // Convert sheet to array of arrays
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

                    // 1. Delete first 3 rows
                    data.splice(0, 3);

                    // 2. Find metadata
                    let metadata = {
                        programa: '',
                        ramo: '',
                        unidad: '',
                        enfoque: '',
                        presupuestoOriginal: { meta: '', ejercido: '', pct: '' },
                        presupuestoModificado: { meta: '', ejercido: '', pct: '' }
                    };
                    let headerRowsToDelete = 0;

                    // 3. Find and delete "PRESUPUESTO" title row
                    const presupuestoTitleIndex = data.findIndex(row => 
                        String(row[0]).trim() === "PRESUPUESTO" && row.slice(1).every(c => c === null)
                    );
                    if (presupuestoTitleIndex > -1) {
                        data.splice(presupuestoTitleIndex, 1);
                    }

                    // 4. Extract data and find how many header rows to delete
                    let lastHeaderRowIndex = -1;
                    data.forEach((row, index) => {
                        const keyColA = String(row[0] || '').trim().replace(/\s+/g, ' '); // Clave principal en Columna A
                        
                        if (keyColA.startsWith("Programa presupuestario")) { metadata.programa = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Ramo")) { metadata.ramo = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Unidad responsable")) { metadata.unidad = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Enfoques transversales")) { metadata.enfoque = row[3] ?? ''; lastHeaderRowIndex = index; }
                        
                        // PRESUPUESTO ORIGINAL: "Meta anual" 2 filas arriba en E (4) o, si no está en E, en C (2)
                        if (keyColA.startsWith("PRESUPUESTO ORIGINAL") && index >= 2 && String(data[index - 2][4] || '').trim() === "Meta anual") {
                            metadata.presupuestoOriginal = { meta: row[4] ?? '', ejercido: row[5] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        } else if (keyColA.startsWith("PRESUPUESTO ORIGINAL") && index >= 2 && String(data[index - 2][2] || '').trim() === "Meta anual") {
                            metadata.presupuestoOriginal = { meta: row[2] ?? '', ejercido: row[4] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        }

                        // PRESUPUESTO MODIFICADO: "Meta anual" 3 filas arriba en E (4) o, si no está en E, en C (2)
                        if (keyColA.startsWith("PRESUPUESTO MODIFICADO") && index >= 3 && String(data[index - 3][4] || '').trim() === "Meta anual") {
                            metadata.presupuestoModificado = { meta: row[4] ?? '', ejercido: row[5] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        } else if (keyColA.startsWith("PRESUPUESTO MODIFICADO") && index >= 3 && String(data[index - 3][2] || '').trim() === "Meta anual") {
                            metadata.presupuestoModificado = { meta: row[2] ?? '', ejercido: row[4] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        }
                    });

                    // 5. Delete all header rows up to the last one found
                    if (lastHeaderRowIndex > -1) {
                        data.splice(0, lastHeaderRowIndex + 2); // +2 para eliminar también la fila de encabezados de la tabla
                    }

                    // 6. Add new headers and data
                    if (data.length > 0) {
                        // Add headers to the first row of data
                        const headers = [
                            "Programa Presupuestario", "Ramo", "Unidad Responsable", "Enfoque Transversal",
                            "PO Meta Anual", "PO Ejercido", "PO % Anual",
                            "PM Meta Anual", "PM Ejercido", "PM % Anual"
                        ];
                        headers.forEach((h, i) => data[0][10 + i] = h); // Start at column K (index 10)

                        // Add data to all subsequent rows
                        const values = [
                            metadata.programa, metadata.ramo, metadata.unidad, metadata.enfoque,
                            metadata.presupuestoOriginal.meta, metadata.presupuestoOriginal.ejercido, metadata.presupuestoOriginal.pct,
                            metadata.presupuestoModificado.meta, metadata.presupuestoModificado.ejercido, metadata.presupuestoModificado.pct
                        ];
                        for (let i = 1; i < data.length; i++) {
                            values.forEach((v, j) => data[i][10 + j] = v);
                        }
                    }

                    // Create a new worksheet with the transformed data
                    const newWs = XLSX.utils.aoa_to_sheet(data);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep2 = processedWb;
                log(`Paso 2 Completado. Se pre-procesaron ${processedCount} hojas.`, 'success');
                setLoading(2, false);
                enableStep(3);
                document.getElementById('dlStep2').classList.remove('hidden');
            } catch (e) {
                log("Error en Paso 2: " + e.message, 'error');
                setLoading(2, false);
            }
        }

        // === STEP 3: EXTRACT MORE METADATA (EJE, PROGRAMA, ETC.) ===
        async function runStep3() {
            setLoading(3, true);
            log("Iniciando Paso 3: Extrayendo metadatos adicionales (Eje, Programa, etc.)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep2) throw new Error("Falta el resultado del Paso 2");

                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of STATE.wbStep2.SheetNames) {
                    const ws = STATE.wbStep2.Sheets[sheetName];

                    if (sheetName.toLowerCase().startsWith('ramo')) {
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        log(`Hoja '${sheetName}' omitida de la extracción de metadatos (comienza con 'Ramo').`);
                        continue;
                    }

                    // --- INICIO: Lógica de extracción de Nivel/Unidad (CORREGIDA) ---
                    // Esta lógica ahora se ejecuta ANTES de la transformación de indicadores.
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });
                    const rowsToDelete = new Set(); // Declaración movida aquí para que esté disponible para toda la función.
                    
                    // Find the header row from Step 2. It's the first row that has "Programa Presupuestario" in column K (index 10)
                    const headerRowIndex = data.findIndex(row => (row[10] || '') === "Programa Presupuestario");

                    const resultadosIndex = data.findIndex(row => String(row[0] || '').trim() === "RESULTADOS");

                    if (resultadosIndex > -1) {

                        const sectionToEnd = data.slice(resultadosIndex + 1);
                        const hasNivel = sectionToEnd.some(row => String(row[0] || '').trim().startsWith("NIVEL:"));
                        
                        let newHeadersAdded = false;
                        const stopTexts = [
                            "Justificación de diferencia de avances con respecto a las metas programadas",
                            "Justificación del ajuste a las metas"
                        ];

                        rowsToDelete.add(resultadosIndex); // Marcar "RESULTADOS" para eliminar

                        if (hasNivel) { // --- MODO NIVEL ---
                            log(`- Hoja '${sheetName}' en 'Modo Nivel'.`);
                            let nivelActual = '';
                            for (let i = resultadosIndex + 1; i < data.length; i++) {
                                const key = String(data[i][0] || '').trim();
                                if (stopTexts.includes(key)) break; // Detenerse si se encuentra texto de justificación

                                if (key.startsWith("NIVEL:")) {
                                    nivelActual = key;
                                    rowsToDelete.add(i);
                                } else if (!rowsToDelete.has(i)) {
                                    if (!newHeadersAdded && headerRowIndex > -1) {
                                        data[headerRowIndex][28] = "NIVEL";
                                        newHeadersAdded = true;
                                    }
                                    data[i][28] = nivelActual;
                                }
                            }
                        } else { // --- MODO UNIDAD ---
                            log(`- Hoja '${sheetName}' en 'Modo Unidad'.`);
                            let unidadActual = '';
                            for (let i = resultadosIndex + 1; i < data.length; i++) {
                                const key = String(data[i][0] || '').trim();
                                if (stopTexts.includes(key)) break; // Detenerse si se encuentra texto de justificación

                                if (key.startsWith("Unidad Responsable*:")) {
                                    unidadActual = key;
                                    rowsToDelete.add(i);
                                } else if (!rowsToDelete.has(i)) {
                                    if (!newHeadersAdded && headerRowIndex > -1) {
                                        data[headerRowIndex][29] = "Unidad Responsable";
                                        newHeadersAdded = true;
                                    }
                                    data[i][29] = unidadActual;
                                }
                            }
                        }
                    }
                    // --- FIN: Lógica de extracción de Nivel/Unidad (CORREGIDA) ---


                    // --- INICIO: Lógica de transformación de indicadores (Paso 3.1) ---
                    // let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null }); // Movido arriba
                    if (data.length === 0) {
                        XLSX.utils.book_append_sheet(processedWb, XLSX.utils.aoa_to_sheet([]), sheetName);
                        continue;
                    }

                    // --- INICIO: Lógica de transformación de indicadores (Refactorizada) ---
                    const indicadoresIndex = data.findIndex(row => String(row[0] || '').trim() === "INDICADORES");
                    if (indicadoresIndex > -1) {
                        // Encontrar dónde termina la sección de indicadores (antes de "Justificación...")
                        const stopTexts = [
                            "Justificación de diferencia de avances con respecto a las metas programadas",
                            "Justificación del ajuste a las metas"
                        ];
                        
                        let endIndex = data.length; // Por defecto, hasta el final
                        for (let i = indicadoresIndex + 1; i < data.length; i++) {
                            const cellText = String(data[i][0] || '').trim();
                            if (stopTexts.some(stopText => cellText.includes(stopText))) {
                                endIndex = i;
                                break;
                            }
                        }
                        
                        const indicatorRows = data.slice(indicadoresIndex + 1, endIndex); // ✅ Solo hasta antes de Justificación
                        const consolidatedIndicators = [];
                        
                        // 1. Encontrar los índices de inicio de cada bloque de indicador.
                        // Un bloque comienza con una fila que contiene "DENOMINACIÓN".
                        const blockStartIndexes = [];
                        indicatorRows.forEach((row, index) => {
                            if (String(row[0] || '').trim() === "DENOMINACIÓN") {
                                blockStartIndexes.push(index);
                            }
                        });

                        // 2. Iterar sobre los índices de inicio para definir y procesar cada bloque.
                        for (let i = 0; i < blockStartIndexes.length; i++) {
                            const start = blockStartIndexes[i];
                            // El final del bloque es el inicio del siguiente, o el final del array si es el último.
                            const end = (i + 1 < blockStartIndexes.length) ? blockStartIndexes[i + 1] : indicatorRows.length;
                            const currentBlock = indicatorRows.slice(start, end);

                            // 3. Procesar el bloque actual y añadirlo a los resultados si es válido.
                            const consolidatedRow = processIndicatorBlock(currentBlock);
                            if (consolidatedRow) consolidatedIndicators.push(consolidatedRow);
                        }

                        // 4. Reemplazar las filas de indicadores originales con las nuevas filas consolidadas.
                        // Se eliminan todas las filas desde "INDICADORES" hasta el final y se insertan las consolidadas.
                        data.splice(indicadoresIndex, data.length - indicadoresIndex, ...consolidatedIndicators);
                    }

                    function processIndicatorBlock(block) {
                        console.log('=== PROCESANDO BLOQUE ===');
                        console.log('Tamaño del bloque:', block.length);
                        console.log('Primera fila:', block[0]);
                        // Un bloque válido debe tener al menos la fila "DENOMINACIÓN" y la fila del nombre.
                        if (!block || block.length < 2) {
                            console.log('❌ Bloque inválido o demasiado corto, omitiendo.');
                            return null;
                        }
                        let baseRow = undefined;
                        const pivotedValues = {
                            aprobada: undefined,
                            ajustada: undefined,
                            realizado: undefined,
                            avance: undefined
                        };

                        // 1. Encontrar la fila base (la que contiene el nombre del indicador).
                        // Esta es la primera fila después de "DENOMINACIÓN" que no está vacía en la columna A.
                        let lastRowWasDenominacion = false;
                        for (const row of block) {
                            const cellA = String(row[0] || '').trim();
                            if (cellA === "DENOMINACIÓN") {
                                lastRowWasDenominacion = true;
                            } else if (lastRowWasDenominacion && cellA !== "") {
                                baseRow = [...row]; // Copiamos la fila para no modificar la original.
                                break; // Salimos del bucle una vez encontrada.
                            }
                        }

                        // Si no se encuentra una fila base (por ejemplo, un bloque con solo "DENOMINACIÓN"), se omite.
                        if (!baseRow) return null;

                        // Si no encontramos una fila base (nombre del indicador), no podemos consolidar.
                        if (!baseRow) return null;

                        // --- INICIO: Mejora para corregir columnas desfasadas ---
                        // En algunas hojas, no hay "OBJETIVOS", por lo que "MÉTODO" está en B y "UNIDAD" en C.
                        // La cabecera "DENOMINACIÓN" está en la primera fila del bloque.
                        const headerRow = block[0];
                        const unidadMedidaInColC = String(headerRow[2] || '').trim() === "UNIDAD DE MEDIDA";

                        if (unidadMedidaInColC) {
                            // Mover C -> D, B -> C, y dejar B vacío.
                            baseRow[3] = baseRow[2]; // Unidad de Medida
                            baseRow[2] = baseRow[1]; // Método de Cálculo
                            baseRow[1] = null;       // Objetivos (vacío)
                        }
                        // --- FIN: Mejora para corregir columnas desfasadas ---

                        // 2. Recorrer todo el bloque para capturar todos los valores a pivotar.
                        for (const row of block) {
                            const keyF = String(row[5] || '').trim();
                            if (keyF.startsWith("Meta anual aprobada")) { pivotedValues.aprobada = row[6]; }
                            if (keyF.startsWith("Meta anual ajustada")) { pivotedValues.ajustada = row[6]; }
                            if (keyF.startsWith("Realizado al Período")) { pivotedValues.realizado = row[6]; }
                            if (keyF.startsWith("Avance realizado al período")) { pivotedValues.avance = row[6]; }
                        }

                        // 3. Asignar los valores capturados a las nuevas columnas en la fila base.
                        baseRow[31] = pivotedValues.aprobada;
                        baseRow[32] = pivotedValues.ajustada;
                        baseRow[33] = pivotedValues.realizado;
                        baseRow[34] = pivotedValues.avance;

                        return baseRow;
                    }
                    // --- FIN: Lógica de transformación de indicadores ---

                    let metadata = {
                        eje: '', programa: '', objetivo: '',
                        finalidad: '', funcion: '', subfuncion: '', actividad: ''
                    };

                    if (headerRowIndex === -1) {
                        log(`Advertencia en '${sheetName}': No se encontró la fila de encabezados del Paso 2. La hoja podría no procesarse correctamente.`, 'error');
                    }

                    // Scan for metadata and mark rows for deletion
                    for (let i = 0; i < data.length; i++) {
                        // No procesar la sección de indicadores que ya fue transformada
                        if (indicadoresIndex > -1 && i >= indicadoresIndex) {
                            break;
                        }

                        const row = data[i];
                        const key = String(row[0] || '').trim().replace(/\s+/g, ' ');
                        const nextRow = data[i + 1];

                        if (key === "Eje" && nextRow) {
                            metadata.eje = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i);
                            rowsToDelete.add(i + 1);
                        }
                        if (key === "Programa" && nextRow) {
                            metadata.programa = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i);
                            rowsToDelete.add(i + 1);
                        }
                        if (key === "Objetivo Prioritario" && nextRow) {
                            metadata.objetivo = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i); // Marcar "Objetivo Prioritario"
                            rowsToDelete.add(i + 1); // Marcar el valor del objetivo

                            // Buscar desde aquí hasta encontrar "CLASIFICACIÓN FUNCIONAL" o "RESULTADOS"
                            for (let j = i + 2; j < data.length; j++) {
                                const subKey = String(data[j][0] || '').trim();
                                if (subKey === "CLASIFICACIÓN FUNCIONAL" || subKey === "RESULTADOS") {
                                    break; // Detenerse al encontrar el siguiente bloque importante
                                }
                                rowsToDelete.add(j); // Marcar para eliminar las filas intermedias
                            }
                        }

                        if (key === "Finalidad") { metadata.finalidad = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Función") { metadata.funcion = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Subfunción") { metadata.subfuncion = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Actividad Institucional") { metadata.actividad = String(row[2] ?? '').trim(); rowsToDelete.add(i); }

                        // Mark title/empty rows for deletion
                        if (key.includes("ALINEACIÓN CON LOS EJES") || key.includes("Alineación con los Programas") || key === "CLASIFICACIÓN FUNCIONAL") rowsToDelete.add(i);

                        // Eliminar la fila "Fichas de Indicadores del Desempeño" si las columnas B-G están vacías.
                        if (key === "Fichas de Indicadores del Desempeño") {
                            const colsBtoG = row.slice(1, 7); // Columnas B a G
                            const areColsEmpty = colsBtoG.every(cell => cell === null || String(cell).trim() === '');
                            if (areColsEmpty) rowsToDelete.add(i);
                        }

                        if (row.every(cell => cell === null || cell === '')) rowsToDelete.add(i);
                    }

                    // --- INICIO: Lógica 3.1 Fortalecida ---
                    let fidNote = '';
                    const textoInicioNota = "*Los Programas presupuestarios pueden ser ejecutados de manera conjunta por diversas";
                    // Revisar las últimas 5 filas, que es donde suele estar la nota.
                    for (let i = Math.max(0, data.length - 5); i < data.length; i++) {
                        const cellText = String(data[i][0] || '').trim();
                        if (cellText.startsWith(textoInicioNota)) {
                            fidNote = cellText; // Capturar el texto completo de la celda
                            rowsToDelete.add(i); // Marcar para eliminar de su posición original
                            break; // Salir una vez encontrada
                        }
                    }

                    // Búsqueda de cualquiera de los dos textos de justificación
                    const justificacionIndex = data.findIndex(row => {
                        const cellText = String(row[0] || '').trim();
                        return cellText === "Justificación de diferencia de avances con respecto a las metas programadas" ||
                               cellText === "Justificación del ajuste a las metas";
                    });

                    if (justificacionIndex > -1) {
                        let denominacionFound = false;
                        for (let i = justificacionIndex + 1; i < data.length; i++) {
                            if (String(data[i][0] || '').trim().includes("DENOMINACIÓN")) {
                                denominacionFound = true;
                                break;
                            }
                        }
                        if (!denominacionFound) {
                            for (let i = justificacionIndex; i < data.length; i++) {
                                rowsToDelete.add(i);
                            }
                        }
                    }
                    // --- FIN: Lógica 3.1 Fortalecida ---

                    // Filter out the marked rows
                    let cleanedData;
                    if (typeof indicadoresIndex !== 'undefined' && indicadoresIndex > -1) {
                      const rowsToDeleteSafe = new Set();
                      for (const idx of rowsToDelete) {
                        if (idx < indicadoresIndex) rowsToDeleteSafe.add(idx);
                      }
                      cleanedData = data.filter((_, index) => {
                        return index === headerRowIndex || !rowsToDeleteSafe.has(index);
                      });
                    } else {
                      cleanedData = data.filter((_, index) => {
                        return index === headerRowIndex || !rowsToDelete.has(index);
                      });
                    }


                    // Add new headers and data
                    if (cleanedData.length > 0) {
                        const headers = [
                            "Eje", "Programa", "Objetivo Prioritario",
                            "Finalidad", "Función", "Subfunción", "Actividad Institucional"
                        ];
                        const fidHeaderIndex = 30; // Colocamos FID en la columna AE (índice 30)

                        // Start at column U (index 20)
                        headers.forEach((h, i) => cleanedData[0][20 + i] = h);
                        if (fidNote) cleanedData[0][fidHeaderIndex] = "FID"; // Añadir encabezado FID solo si se encontró la nota

                        // Añadir encabezados de pivote
                        if (indicadoresIndex > -1) {
                            // CORRECCIÓN FINAL: Asegurar que todos los encabezados importantes se mantengan o se restauren
                            // en la fila 0, ya que la lógica de indicadores puede sobrescribirla.
                            const headerRow = cleanedData[0];
                            headerRow[0] = "DENOMINACIÓN";
                            headerRow[1] = "OBJETIVOS";
                            headerRow[2] = "MÉTODO DE CÁLCULO";
                            headerRow[3] = "UNIDAD DE MEDIDA";
                            headerRow[4] = "TIPO-DIMENSIÓN-FRECUENCIA";
                            if (headerRow[21] === "NIVEL") headerRow[21] = "NIVEL"; // Restaurar encabezado NIVEL
                            // Encabezados de Metas a partir de AF (índice 31)
                            const pivotHeaders = [
                                "Meta Anual Aprobada",
                                "Meta Anual Ajustada",
                                "Realizado al Período",
                                "Avance %"
                            ];
                            pivotHeaders.forEach((h, i) => headerRow[31 + i] = h);
                        }

                        const values = [
                            metadata.eje, metadata.programa, metadata.objetivo,
                            metadata.finalidad, metadata.funcion, metadata.subfuncion, metadata.actividad
                        ];
                        for (let i = 1; i < cleanedData.length; i++) {
                            values.forEach((v, j) => cleanedData[i][20 + j] = v);
                            if (fidNote) cleanedData[i][fidHeaderIndex] = fidNote; // Añadir el valor de la nota a cada fila
                        }
                    }

                    // --- INICIO: Lógica de limpieza final del Paso 3 ---
                    // 1. MEJORA: Eliminar filas que contengan "Cadena de Alineación" en la columna A.
                    // Esto cubre "Primera Cadena de Alineación", "Segunda...", etc.
                    cleanedData = cleanedData.filter(row => !String(row[0] || '').trim().endsWith("Cadena de Alineación"));

                    // 2. Eliminar filas donde las columnas A-G están vacías (excepto la cabecera, que se mantiene con la lógica anterior).
                    cleanedData = cleanedData.filter((row, index) => {
                        if (index === 0) return true; // Siempre mantener la fila de encabezado.
                        const firstSevenCols = row.slice(0, 7);
                        return firstSevenCols.some(cell => cell !== null && cell !== undefined && String(cell).trim() !== '');
                    });

                    // 3. Eliminar las columnas F, G, H, I, J (índices 5, 6, 7, 8, 9).
                    // Esto se hace en cada fila. El método splice(5, 5) elimina 5 elementos a partir del índice 5.
                    cleanedData.forEach(row => {
                        if (row.length > 9) { // Asegurarse de que la fila tenga suficientes columnas para evitar errores.
                            row.splice(5, 5);
                        }
                    });
                    // --- FIN: Lógica de limpieza final del Paso 3 ---

                    const newWs = XLSX.utils.aoa_to_sheet(cleanedData);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep3 = processedWb;
                log(`Paso 3 Completado. Se extrajeron metadatos de ${processedCount} hojas.`, 'success');
                setLoading(3, false);
                enableStep('3_1');
                document.getElementById('dlStep3').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 3: " + e.message, 'error');
                setLoading(3, false);
            }
        }

        // === STEP 3.1: CLEAN "RAMO" SHEETS ===
        async function runStep3_1() {
            setLoading('3_1', true);
            log("Iniciando Paso 3.1: Limpiando hojas 'Ramo'...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep3) throw new Error("Falta el resultado del Paso 3");

                const sourceWb = STATE.wbStep3;
                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of sourceWb.SheetNames) {
                    const ws = sourceWb.Sheets[sheetName];

                    // Solo procesar hojas "Ramo"
                    if (!sheetName.toLowerCase().startsWith('ramo')) {
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName); // Copiar las otras hojas sin cambios
                        continue;
                    }

                    log(`Procesando hoja 'Ramo': ${sheetName}`);
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

                    // --- INICIO: Lógica para extraer "Nombre Ramo" (Requerimiento específico) ---
                    let nombreRamo = '';
                    // Buscar en la columna A (índice 0) antes de cualquier modificación
                    for (const row of data) {
                        const cellValue = String(row[0] || '').trim();
                        if (cellValue.startsWith("Ramo")) {
                            const parts = cellValue.split('\n');
                            if (parts.length > 1) {
                                nombreRamo = parts.slice(1).join(' ').trim(); // Tomar todo después del primer salto de línea
                            } else {
                                nombreRamo = cellValue; // Fallback si no hay salto de línea
                            }
                            log(`- Se encontró el nombre del Ramo: '${nombreRamo}'`);
                            break; // Dejar de buscar una vez encontrado
                        }
                    }
                    // --- FIN: Lógica para extraer "Nombre Ramo" ---


                    // 1. Buscar la fila de cabecera "Clave Programa presupuestario" en la columna B (índice 1)
                    const headerRowIndex = data.findIndex(row => String(row[1] || '').trim() === "Clave Programa presupuestario");

                    if (headerRowIndex === -1) {
                        log(`Advertencia: No se encontró la cabecera 'Clave Programa presupuestario' en la hoja ${sheetName}. Se copiará sin cambios.`, 'error');
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        continue;
                    }

                    // 2. Eliminar todas las filas anteriores a la cabecera
                    if (headerRowIndex > 0) {
                        data.splice(0, headerRowIndex);
                        log(`- Se eliminaron ${headerRowIndex} filas de cabecera.`);
                    }

                    // 3. Eliminar la columna A (índice 0) de cada fila
                    data.forEach(row => row.splice(0, 1));
                    log(`- Se eliminó la columna A.`);

                    // --- INICIO: Insertar el "Nombre Ramo" extraído en la columna I (índice 8) ---
                    // MEJORA: Asegurar que la columna se cree siempre para evitar desfases, incluso si nombreRamo está vacío.
                    if (data.length > 0) {
                        data[0][8] = "Nombre Ramo"; // Añadir encabezado en la nueva columna I
                        // Solo rellenar si se encontró un valor.
                        if (nombreRamo) {
                            for (let i = 1; i < data.length; i++) data[i][8] = nombreRamo;
                        }
                    }

                    // 4. Rellenar vacíos (lógica similar al Paso 6) en las primeras 6 columnas nuevas (ex B-G)
                    const NUM_COLS_TO_FILL = 6; // A-F
                    let lastValues = new Array(NUM_COLS_TO_FILL).fill(null);
                    let filledCount = 0;

                    for (let r = 1; r < data.length; r++) { // Empezar desde la fila 1 (después de la cabecera)
                        for (let c = 0; c < NUM_COLS_TO_FILL; c++) {
                            const cellValue = data[r][c];
                            if (cellValue === null || String(cellValue).trim() === '') {
                                if (lastValues[c] !== null) {
                                    data[r][c] = lastValues[c];
                                    filledCount++;
                                }
                            } else {
                                lastValues[c] = cellValue;
                            }
                        }
                    }
                    log(`- Se rellenaron ${filledCount} celdas vacías en las primeras 6 columnas.`);

                    const newWs = XLSX.utils.aoa_to_sheet(data);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep3_1 = processedWb;
                log(`Paso 3.1 Completado. Se limpiaron ${processedCount} hojas 'Ramo'.`, 'success');
                setLoading('3_1', false);
                enableStep(4);
                document.getElementById('dlStep3_1').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 3.1: " + e.message, 'error');
                setLoading('3_1', false);
            }
        }

        // === STEP 4: CONSOLIDATE SHEETS (A:T + Label in U) ===
        async function runStep4() {
            setLoading(4, true);
            log("Iniciando Paso 4: Consolidando hojas en dos grupos (Ramo y General)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep3_1) throw new Error("Falta el resultado del Paso 3.1");

                const sourceWb = STATE.wbStep3_1;
                const destWb = XLSX.utils.book_new();

                let ramoData = [];
                let generalData = [];
                const DEST_SHEET_RAMO = "CONSOLIDADO_RAMO";
                const DEST_SHEET_GENERAL = "CONSOLIDADO_GENERAL";

                sourceWb.SheetNames.forEach(sheetName => {
                    const ws = sourceWb.Sheets[sheetName];
                    const data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

                    if (data.length === 0) return;

                    const targetArray = sheetName.toLowerCase().startsWith('ramo') ? ramoData : generalData;

                    // Si es la primera vez que agregamos datos a este grupo, añadimos la cabecera.
                    if (targetArray.length === 0 && data.length > 0) {
                        // La primera fila de 'data' es la cabecera del paso 3.
                        const headerRow = data[0];
                        headerRow.push("NOMBRE_HOJA_ORIGEN");
                        headerRow.push("ES_FID"); // Nuevo encabezado para la marca FID
                        targetArray.push(headerRow);
                    }

                    // Añadir el nombre de la hoja a cada fila (excepto la de cabecera).
                    data.forEach((row, index) => {
                        // Omitir la fila de cabecera (index 0) y las filas completamente vacías.
                        if (index > 0) {
                            // MEJORA: Una fila se considera vacía si no tiene un valor significativo.
                            // Para las hojas 'Ramo', la columna G (índice 6, "Original Aprobado") debe tener un valor.
                            // Para las hojas generales, la columna A (índice 0, "DENOMINACIÓN") debe tener un valor.
                            const isRamoSheet = sheetName.toLowerCase().startsWith('ramo');
                            const significantCellIndex = isRamoSheet ? 6 : 0; // Col G para Ramo, Col A para General
                            const significantCell = row[significantCellIndex];
                            const isRowEffectivelyEmpty = significantCell === "" || significantCell === null || significantCell === undefined;
                            
                            if (!isRowEffectivelyEmpty) {
                                const dataRow = row;
                                dataRow.push(sheetName); // Añadir el nombre de la hoja origen
                                
                                // Añadir la marca "FID" si corresponde
                                const isFidMarked = STATE.fidMarkedSheetNames.has(sheetName);
                                dataRow.push(isFidMarked ? "FID" : "");
                                targetArray.push(dataRow);
                            }
                        }
                    });
                });

                // Create and append sheets if they have data
                if (ramoData.length > 0) {
                    const newWsRamo = XLSX.utils.aoa_to_sheet(ramoData);
                    XLSX.utils.book_append_sheet(destWb, newWsRamo, DEST_SHEET_RAMO);
                    log(`- Grupo 'Ramo': ${ramoData.length} filas generadas en la hoja '${DEST_SHEET_RAMO}'.`);
                } else {
                    log("- Grupo 'Ramo': No se encontraron hojas que comenzaran con 'Ramo'.");
                }

                if (generalData.length > 0) {
                    const newWsGeneral = XLSX.utils.aoa_to_sheet(generalData);
                    XLSX.utils.book_append_sheet(destWb, newWsGeneral, DEST_SHEET_GENERAL);
                    log(`- Grupo 'General': ${generalData.length} filas generadas en la hoja '${DEST_SHEET_GENERAL}'.`);
                } else {
                    log("- Grupo 'General': No se encontraron hojas que no comenzaran con 'Ramo'.");
                }

                // The next step (unmerge) needs to know which sheet to process.
                // The macro seems to imply the main consolidation is the non-Ramo one.
                // Let's rename the general one to the original name for compatibility with next steps.
                if (destWb.Sheets[DEST_SHEET_GENERAL]) {
                    destWb.Sheets["CONSOLIDADO_TOTAL"] = destWb.Sheets[DEST_SHEET_GENERAL];
                    delete destWb.Sheets[DEST_SHEET_GENERAL];
                    destWb.SheetNames[destWb.SheetNames.indexOf(DEST_SHEET_GENERAL)] = "CONSOLIDADO_TOTAL";
                }

                STATE.wbStep4 = destWb;
                log(`Paso 4 Completado. Se crearon ${destWb.SheetNames.length} hojas consolidadas.`, 'success');
                setLoading(4, false);
                enableStep(5);
                document.getElementById('dlStep4').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 4: " + e.message, 'error');
                setLoading(4, false);
            }
        }

        // === STEP 5: UNMERGE ALL ===
        async function runStep5() {
            // ADVERTENCIA: Este paso y los siguientes (4 y 5) operarán sobre la hoja "CONSOLIDADO_TOTAL".
            // La hoja "CONSOLIDADO_RAMO" no será modificada por los pasos posteriores.
            // Esto replica el comportamiento más probable de la macro original, que se enfoca en un solo flujo de datos.

            setLoading(5, true);
            log("Iniciando Paso 5: Descombinando celdas...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep4) throw new Error("Falta el resultado del Paso 4");
                
                // Clone workbook logic (SheetJS objects are references, so we should be careful)
                // Since we are moving forward, we can modify the previous WB or clone data.
                // Simplest: Write to buffer and read back to deep clone, or just modify the object if we don't care about history.
                // Let's modify object directly but save as new reference in state for clarity.
                
                const wb = STATE.wbStep4; // We will modify this directly effectively
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"]; // This is the target sheet

                if (!ws) {
                    log("No se encontró la hoja 'CONSOLIDADO_TOTAL' para descombinar. Saltando paso.", 'error');
                    throw new Error("Hoja 'CONSOLIDADO_TOTAL' no encontrada.");
                }
                
                // Unmerge logic in SheetJS: simply delete the '!merges' property
                if (ws['!merges']) {
                    const count = ws['!merges'].length;
                    delete ws['!merges'];
                    log(`Se eliminaron ${count} configuraciones de fusión de celdas.`);
                } else {
                    log("No se encontraron celdas combinadas.");
                }

                STATE.wbStep5 = wb; // Pointer to same object (modified)
                
                log("Paso 5 Completado.", 'success');
                setLoading(5, false);
                enableStep(6);
                document.getElementById('dlStep5').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 5: " + e.message, 'error');
                setLoading(5, false);
            }
        }

        // === STEP 6: FILL BLANKS (Column A-F) ===
        async function runStep6() {
            setLoading(6, true);
            log("Iniciando Paso 6: Rellenando vacíos en Columnas A-F...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep5) throw new Error("Falta el resultado del Paso 5");
                if (!STATE.wbStep5.Sheets["CONSOLIDADO_TOTAL"]) {
                    log("No se encontró la hoja 'CONSOLIDADO_TOTAL' para rellenar. Saltando paso.", 'error');
                    throw new Error("Hoja 'CONSOLIDADO_TOTAL' no encontrada.");
                }

                const wb = STATE.wbStep4;
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"];
                
                // Get range
                const range = XLSX.utils.decode_range(ws['!ref']);
                const NUM_COLS_TO_FILL = 6; // A=0, B=1, C=2, D=3, E=4, F=5
                let lastValues = new Array(NUM_COLS_TO_FILL).fill(null);
                let filledCount = 0;

                // Loop through each row
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    // Loop through columns A to F
                    for (let C = 0; C < NUM_COLS_TO_FILL; ++C) {
                        const cellRef = XLSX.utils.encode_cell({c: C, r: R});
                        const cell = ws[cellRef];

                        // Check if cell is empty or has no value
                        if (!cell || cell.v === undefined || cell.v === "") {
                            // If it's empty but we have a last known value for this column, fill it
                            if (lastValues[C] !== null) {
                                ws[cellRef] = { v: lastValues[C], t: 's' }; // Use 's' for string type
                                filledCount++;
                            }
                        } else {
                            // If cell has a value, update the last known value for this column
                            lastValues[C] = cell.v;
                        }
                    }
                }

                // --- INICIO: Lógica agregada para filtrar y marcar "FID" ---
                log("Iniciando búsqueda de texto para marcar 'FID' en columna I...");
                const textoBusqueda = "Los Programas presupuestarios pueden ser ejecutados de manera conjunta por diversas Unidades Responsables para el cumplimiento de sus objetivos y metas. Para fines de recolección de la información del logro de los objetivos y metas establecidos en la Ficha de Indicadores del Desempeño (FID), en los reportes se asocia a una o más Unidades Responsables, que no necesariamente representan la totalidad de ellas. Por ello, para facilitar la identificación de las Unidades Responsables, se puede consultar el Estado Analítico del Ejercicio del Presupuesto de Egresos en Clasificación Funcional-Programática de cada Ramo en la Cuenta Pública 2024.";
                let fidCount = 0;

                // Recorrer filas nuevamente para buscar el texto en la columna A
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    const cellRefA = XLSX.utils.encode_cell({c: 0, r: R}); // Columna A
                    const cellA = ws[cellRefA];

                    // Normalizar el texto de la celda para una comparación robusta
                    const cellValue = (cellA && cellA.v) ? String(cellA.v).trim().replace(/\s+/g, ' ') : "";
                    const targetValue = textoBusqueda.replace(/\s+/g, ' ');

                    if (cellValue === targetValue) {
                        const cellRefI = XLSX.utils.encode_cell({c: 8, r: R}); // Columna I
                        
                        // Crear o actualizar la celda en la columna I
                        ws[cellRefI] = { v: "FID", t: 's' };
                        fidCount++;
                    }
                }

                if (fidCount > 0) {
                    log(`Se marcaron ${fidCount} filas con 'FID' en la columna I.`, 'success');
                }
                // --- FIN: Lógica agregada ---

                STATE.wbStep6 = wb;
                
                log(`Paso 6 Completado. Se rellenaron ${filledCount} celdas y se marcaron ${fidCount} filas como FID.`, 'success');
                setLoading(6, false);
                document.getElementById('dlStep6').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 6: " + e.message, 'error');
                setLoading(6, false);
            }
        }

        // === STYLING UTILITY ===
        function applyStylesToWorkbook(wb) {
            const defaultFont = { name: 'Noto Sans', sz: 9 };
            const borderStyle = { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } };
            
            const headerStyleGeneral = {
                font: { name: 'Noto Sans', sz: 9, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "9C2348" } }, // Guinda
                border: borderStyle
            };
            const headerStyleRamo = {
                font: { name: 'Noto Sans', sz: 9, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "1E5B4F" } }, // Verde Oscuro
                border: borderStyle
            };
            const defaultCellStyle = {
                font: defaultFont,
                border: borderStyle
            };

            wb.SheetNames.forEach(sheetName => {
                const ws = wb.Sheets[sheetName];
                const range = XLSX.utils.decode_range(ws['!ref']);

                // Aplicar color a la pestaña de la hoja
                if (!ws['!props']) ws['!props'] = {};
                if (sheetName.includes("RAMO")) {
                    ws['!props'].tabColor = { rgb: "1E5B4F" }; // Verde Oscuro
                } else {
                    ws['!props'].tabColor = { rgb: "9C2348" }; // Guinda
                }

                // Iterar sobre todas las celdas para aplicar estilos
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = { c: C, r: R };
                        const cell_ref = XLSX.utils.encode_cell(cell_address);
                        let cell = ws[cell_ref];
                        if (!cell) cell = ws[cell_ref] = { t: 's', v: '' }; // Crear celda si no existe

                        // Aplicar estilo de encabezado a la primera fila
                        if (R === 0) {
                            if (sheetName.includes("RAMO")) {
                                cell.s = headerStyleRamo;
                            } else {
                                cell.s = headerStyleGeneral;
                            }
                        } else { // Aplicar estilo por defecto al resto
                            cell.s = defaultCellStyle;
                        }
                    }
                }
            });

            return wb;
        }

        // === UTILS ===
        function enableStep(num) {
            const card = document.getElementById(`cardStep${num}`);
            card.classList.remove('disabled');
            if (num == 2) document.getElementById('allInOneStep').classList.remove('hidden');
        }

        function setLoading(stepNum, isLoading) {
            const btn = document.querySelector(`#cardStep${stepNum} button`);
            if (isLoading) {
                btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Procesando...`;
                btn.disabled = true;
                btn.classList.add('opacity-75');
            } else {
                btn.innerHTML = `<span>Re-ejecutar</span>`;
                btn.disabled = false;
                btn.classList.remove('opacity-75');
            }
        }

        function downloadStep(stepNum) {
            let wb = null;
            let filename = "";
            
            switch(stepNum) {
                case 1: 
                    wb = STATE.wbStep1; 
                    filename = "1_Libros_Unificados.xlsx"; 
                    break;
                case 2: 
                    wb = STATE.wbStep2; 
                    filename = "2_PreProcesado.xlsx"; 
                    break;
                case 3: 
                    wb = STATE.wbStep3; 
                    filename = "3_Metadatos_Extraidos.xlsx"; 
                    break;
                case '3.1': 
                    wb = STATE.wbStep3_1; 
                    filename = "3_1_Ramo_Limpiado.xlsx"; 
                    break;
                case 4: 
                    wb = STATE.wbStep4; 
                    filename = "4_Hojas_Consolidadas.xlsx"; 
                    break;
                case 5: 
                    wb = STATE.wbStep5; 
                    filename = "5_Descombinado.xlsx"; 
                    break;
                case 6: 
                    wb = STATE.wbStep6; 
                    filename = "6_FINAL_Rellenado.xlsx"; 
                    break;
            }

            if (wb) {
                const styledWb = applyStylesToWorkbook(wb);
                // Antes de descargar, aseguramos la limpieza final si es el último paso
                XLSX.writeFile(wb, filename);
            }
        }
    </script>
</body>
</html>
