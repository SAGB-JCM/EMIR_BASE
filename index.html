<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consolidar Excel Automatizado</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Librerías Necesarias -->
    <!-- JSZip para manejar archivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- SheetJS (xlsx) para manipular Excel -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <!-- FontAwesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Colores Institucionales */
        :root {
            --primary-color: #9C2348; /* Guinda */
            --secondary-color: #A6802D; /* Dorado */
            --accent-color: #1E5B4F; /* Verde Oscuro */
            --success-color: #10B981; /* Verde Claro */
            --danger-color: #EF4444; /* Rojo */
        }
        .step-card {
            transition: all 0.3s ease;
        }
        .step-card.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(100%);
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans">

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        
        <!-- Header -->
        <header class="mb-10 text-center flex flex-col items-center">
            <img src="https://github.com/SAGB-JCM/EMIR_BASE/blob/main/Gemini_Generated_Image_gfdjv0gfdjv0gfdj.png?raw=true" alt="Logo" class="w-24 h-24 mb-4 rounded-md shadow-lg">
            <h1 class="text-4xl font-bold text-[#9C2348] mb-2">
                Consolidador de Matrices de Indicadores (EMIR)
            </h1>
            <p class="text-gray-600 max-w-3xl">Herramienta elaborada en el marco del contrato de prestación de servicios DC-620-2025 con el objetivo de consolidar las Matrices de Indicadores para Resultados de la Cuenta Pública 2024.</p>
        </header>

        <!-- Instructions -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8 border-l-4 border-[#A6802D]">
            <h2 class="font-bold text-lg mb-2 text-[#A6802D]"><i class="fa-solid fa-circle-info mr-2"></i>Instrucciones de Uso</h2>
            <ol class="list-decimal list-inside text-gray-700 space-y-1">
                <li>Cargue el archivo <strong>.zip</strong> que contiene los archivos Excel de la Cuenta Pública usando la <strong>Opción A</strong>.</li>
                <li>Opcionalmente, use la <strong>Opción B</strong> para intentar descargar el archivo directamente desde la URL de Hacienda (puede fallar por seguridad).</li>
                <li>Una vez cargado el archivo, presione el botón <strong>"Ejecutar Todo y Descargar"</strong> para realizar el proceso completo de forma automática.</li>
                <li>Si lo prefiere, puede ejecutar cada paso del proceso de forma individual y descargar los resultados intermedios.</li>
            </ol>
        </div>

        <!-- Input Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Opción 1: Subir Local -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-[#9C2348] transition-colors">
                    <i class="fa-solid fa-upload text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Opción A: Subir ZIP Local</h3>
                    <input type="file" id="fileInput" accept=".zip" class="hidden" onchange="handleFileUpload(this)">
                    <label for="fileInput" class="cursor-pointer bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition">
                        Seleccionar Archivo .zip
                    </label>
                </div>

                <!-- Opción 2: URL -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50">
                    <i class="fa-solid fa-globe text-4xl text-gray-400 mb-4 block text-center"></i>
                    <h3 class="font-bold mb-2 text-center">Opción B: URL (Hacienda)</h3>
                    <div class="flex gap-2">
                        <input type="text" id="urlInput" 
                            value="https://www.cuentapublica.hacienda.gob.mx/work/models/CP/2024/tomo/III/E_MIR.zip"
                            class="flex-1 border border-gray-300 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-[#1E5B4F] focus:border-[#1E5B4F]" placeholder="https://...">
                        <button onclick="handleUrlDownload()" class="bg-[#1E5B4F] text-white px-4 py-2 rounded hover:bg-opacity-90 transition">
                            <i class="fa-solid fa-download"></i>
                        </button>
                    </div>
                    <p class="text-xs text-red-500 mt-2">Nota: Si la descarga falla por seguridad (CORS), descarga el ZIP manualmente y usa la Opción A.</p>
                </div>
            </div>
        </div>

        <!-- Log & Status Area -->
        <div id="statusArea" class="hidden bg-gray-900 text-green-400 font-mono text-sm p-4 rounded-lg mb-8 h-48 overflow-y-auto shadow-inner">
            <div id="logContent">Esperando archivo...</div>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="hidden mb-8">
            <h2 class="text-xl font-bold mb-4">Contenido del ZIP</h2>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="min-w-full">
                    <thead class="bg-gray-200 text-gray-700">
                        <tr>
                            <th class="py-2 px-4 text-left">Archivo</th>
                            <th class="py-2 px-4 text-left">Hojas Detectadas</th>
                            <th class="py-2 px-4 text-left">Estado</th>
                        </tr>
                    </thead>
                    <tbody id="fileListBody" class="text-sm">
                        <!-- Rows injected here -->
                    </tbody>
                </table>
            </div>
            <div class="mt-2 text-right text-sm text-gray-500">
                Total archivos Excel encontrados: <span id="totalFilesCount" class="font-bold">0</span>
            </div>
        </div>

        <!-- All-in-One Step -->
        <div id="allInOneStep" class="hidden bg-white rounded-lg shadow-lg p-6 mb-8 border-t-4 border-[#9C2348]">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div>
                    <h2 class="text-xl font-bold text-[#9C2348]">Proceso Completo (Recomendado)</h2>
                    <p class="text-gray-600 text-sm mt-1">Ejecuta todos los pasos necesarios (1, 2, 3, 3.1 y 4) y descarga el archivo final con un solo clic.</p>
                </div>
                <button id="runAllBtn" onclick="runAllSteps()" class="w-full md:w-auto bg-[#9C2348] text-white px-6 py-3 rounded-lg hover:bg-opacity-90 transition-transform transform hover:scale-105 flex justify-center items-center gap-2 font-bold shadow-md hover:shadow-lg">
                    <i class="fa-solid fa-rocket"></i>
                    <span>Ejecutar Todo y Descargar</span>
                </button>
            </div>
        </div>

        <!-- Processing Steps (Wizard) -->
        <div id="processingSteps" class="hidden grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-7 gap-4">
            
            <!-- Step 1 -->
            <div id="cardStep1" class="step-card bg-white p-4 rounded-lg shadow border-l-4 border-[#9C2348]">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 1</h3>
                    <span class="text-xs bg-red-100 text-[#9C2348] px-2 py-1 rounded">Consolidar Libros</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Une todos los archivos del ZIP en un solo libro de Excel.</p>
                <button onclick="runStep1()" class="w-full bg-[#9C2348] text-white py-2 rounded hover:bg-opacity-90 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep1" onclick="downloadStep(1)" class="hidden mt-2 w-full border border-[#9C2348] text-[#9C2348] py-1 rounded hover:bg-red-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 2 -->
            <div id="cardStep2" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-teal-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 2</h3>
                    <span class="text-xs bg-teal-100 text-teal-800 px-2 py-1 rounded">Formato Relacional</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Limpia y transforma hojas (no "Ramo") a formato relacional.</p>
                <button onclick="runStep2()" class="w-full bg-teal-600 text-white py-2 rounded hover:bg-teal-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep2" onclick="downloadStep(2)" class="hidden mt-2 w-full border border-teal-600 text-teal-600 py-1 rounded hover:bg-teal-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 3 -->
            <div id="cardStep3" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-indigo-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 3</h3>
                    <span class="text-xs bg-indigo-100 text-indigo-800 px-2 py-1 rounded">Extraer Datos</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Extrae Eje, Programa, Objetivo y Clasificación Funcional.</p>
                <button onclick="runStep3()" class="w-full bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep3" onclick="downloadStep(3)" class="hidden mt-2 w-full border border-indigo-600 text-indigo-600 py-1 rounded hover:bg-indigo-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 3.1 -->
            <div id="cardStep3_1" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-cyan-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 3.1</h3>
                    <span class="text-xs bg-cyan-100 text-cyan-800 px-2 py-1 rounded">Limpiar "Ramo"</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Limpia, recorta y rellena las hojas cuyo nombre empieza con "Ramo".</p>
                <button onclick="runStep3_1()" class="w-full bg-cyan-600 text-white py-2 rounded hover:bg-cyan-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep3_1" onclick="downloadStep('3.1')" class="hidden mt-2 w-full border border-cyan-600 text-cyan-600 py-1 rounded hover:bg-cyan-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 4 -->
            <div id="cardStep4" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-purple-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 4</h3>
                    <span class="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">Unificar Hojas</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Une todas las hojas en dos grupos: Ramo y General.</p>
                <button onclick="runStep4()" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep4" onclick="downloadStep(4)" class="hidden mt-2 w-full border border-purple-600 text-purple-600 py-1 rounded hover:bg-purple-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 5 -->
            <div id="cardStep5" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-orange-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 5</h3>
                    <span class="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">Descombinar</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Elimina celdas combinadas en la hoja consolidada.</p>
                <button onclick="runStep5()" class="hidden w-full bg-orange-600 text-white py-2 rounded hover:bg-orange-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep5" onclick="downloadStep(5)" class="hidden mt-2 w-full border border-orange-600 text-orange-600 py-1 rounded hover:bg-orange-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 6 -->
            <div id="cardStep6" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-green-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 6</h3>
                    <span class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Rellenar Vacíos</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Rellena celdas vacías en Columnas A-F con el valor superior.</p>
                <button onclick="runStep6()" class="hidden w-full bg-green-600 text-white py-2 rounded hover:bg-green-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep6" onclick="downloadStep(6)" class="hidden mt-2 w-full border border-green-600 text-green-600 py-1 rounded hover:bg-green-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar Final
                </button>
            </div>
        </div>

    </div>

    <!-- MAIN LOGIC SCRIPT -->
    <script>
        // === STATE MANAGEMENT ===
        const STATE = {
            zipFiles: [], // Array of objects { name, data (arraybuffer) }
            wbStep1: null, // The workbook object after Step 1
            wbStep2: null, // The workbook object after Step 2
            wbStep3: null, // The workbook object after Step 3,
            wbStep3_1: null, // The workbook object after Step 3.1
            wbStep4: null, // The workbook object after Step 4
            wbStep5: null, // The workbook object after Step 5
            wbStep6: null  // The workbook object after Step 6
        };

        // === LOGGING UTILS ===
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('logContent');
            const color = type === 'error' ? 'text-red-500' : (type === 'success' ? 'text-green-300' : 'text-green-400');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div class="${color}">[${time}] ${msg}</div>`;
            document.getElementById('statusArea').scrollTop = document.getElementById('statusArea').scrollHeight;
        }

        // === FILE HANDLING ===
        async function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            processZip(file);
        }

        async function handleUrlDownload() {
            const url = document.getElementById('urlInput').value;
            // Usamos un proxy CORS gratuito para demos. En producción real, necesitarías tu propio backend.
            // allorigins.win o corsproxy.io son comunes.
            const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
            
            document.getElementById('statusArea').classList.remove('hidden');
            log(`Intentando descargar desde: ${url} ...`);
            log(`Usando proxy CORS para evadir restricciones de navegador...`);

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Error en descarga: ' + response.statusText);
                const blob = await response.blob();
                processZip(blob);
            } catch (error) {
                log(`Error: ${error.message}. Intenta descargar el archivo manualmente y usar la Opción A.`, 'error');
            }
        }

        async function processZip(blobOrFile) {
            document.getElementById('statusArea').classList.remove('hidden');
            document.getElementById('processingSteps').classList.add('hidden');
            document.getElementById('previewSection').classList.add('hidden');
            
            log("Abriendo archivo ZIP...");
            
            try {
                const zip = new JSZip();
                const contents = await zip.loadAsync(blobOrFile);
                
                STATE.zipFiles = [];
                const tableBody = document.getElementById('fileListBody');
                tableBody.innerHTML = '';
                let fileCount = 0;

                // Iterate through files in ZIP
                const promises = [];
                
                contents.forEach((relativePath, zipEntry) => {
                    // Filter for excel files, ignore MACOSX junk
                    if (!zipEntry.dir && !relativePath.includes('__MACOSX') && (relativePath.endsWith('.xls') || relativePath.endsWith('.xlsx'))) {
                        const p = zipEntry.async("arraybuffer").then(data => {
                            // Basic read to get sheet count without full parsing overhead if possible
                            // But SheetJS read is sync, so we wrap later.
                            STATE.zipFiles.push({
                                name: relativePath,
                                data: data,
                                fileNameSimple: relativePath.split('/').pop()
                            });
                        });
                        promises.push(p);
                    }
                });

                log(`Extrayendo ${promises.length} archivos Excel...`);
                await Promise.all(promises);

                STATE.zipFiles.forEach((file, index) => {
                    fileCount++;
                    const tr = document.createElement('tr');
                    tr.className = "border-b hover:bg-gray-50";
                    tr.innerHTML = `
                        <td class="py-2 px-4 truncate max-w-xs" title="${file.name}">${file.name}</td>
                        <td class="py-2 px-4 text-gray-500 italic">Pendiente de lectura</td>
                        <td class="py-2 px-4 text-yellow-600"><i class="fa-regular fa-clock"></i> Listo para procesar</td>
                    `;
                    tableBody.appendChild(tr);
                });

                document.getElementById('totalFilesCount').innerText = fileCount;
                
                if (fileCount > 0) {
                    document.getElementById('previewSection').classList.remove('hidden');
                    document.getElementById('processingSteps').classList.remove('hidden');
                    document.getElementById('allInOneStep').classList.remove('hidden');
                    log("ZIP procesado exitosamente. Listo para Paso 1.", 'success');
                } else {
                    log("No se encontraron archivos .xls o .xlsx válidos en el ZIP.", 'error');
                }

            } catch (e) {
                log("Error leyendo el ZIP: " + e.message, 'error');
            }
        }

        // === ALL-IN-ONE PROCESS ===
        async function runAllSteps() {
            const btn = document.getElementById('runAllBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Procesando...`;
            btn.disabled = true;

            try {
                log("--- INICIANDO PROCESO COMPLETO ---", "success");

                await runStep1();
                if (!STATE.wbStep1) throw new Error("El Paso 1 falló y detuvo el proceso.");

                await runStep2();
                if (!STATE.wbStep2) throw new Error("El Paso 2 falló y detuvo el proceso.");

                await runStep3();
                if (!STATE.wbStep3) throw new Error("El Paso 3 falló y detuvo el proceso.");

                await runStep3_1();
                if (!STATE.wbStep3_1) throw new Error("El Paso 3.1 falló y detuvo el proceso.");

                await runStep4();
                if (!STATE.wbStep4) throw new Error("El Paso 4 falló y detuvo el proceso.");

                log("--- PROCESO COMPLETO FINALIZADO ---", "success");
                log("Descargando archivo final...", "info");

                // Aplicar limpieza final antes de descargar
                log("Aplicando limpieza final (unificar columnas, eliminar vacías)...");
                const finalWb = applyFinalCleanup(STATE.wbStep4);

                const styledWb = applyStylesToWorkbook(finalWb);
                XLSX.writeFile(styledWb, "EMIR_CONSOLIDADO_FINAL.xlsx");

            } catch (error) {
                log(`Error en el proceso completo: ${error.message}`, 'error');
                log("El proceso se ha detenido. Revisa los logs para más detalles.", 'error');
            } finally {
                // Restaurar el botón
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        // === FINAL CLEANUP UTILITY ===
        function applyFinalCleanup(wb) {
            const sheetName = "CONSOLIDADO_TOTAL";
            const ws = wb.Sheets[sheetName];
            if (!ws) {
                log("Advertencia: No se encontró la hoja 'CONSOLIDADO_TOTAL' para la limpieza final.", "error");
                return wb;
            }

            let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

            if (data.length < 2) {
                log("Advertencia: La hoja 'CONSOLIDADO_TOTAL' no tiene datos suficientes para la limpieza final.", "error");
                return wb;
            }

            // Indices de columnas: H=7, W=22, Y=24, Z=25
            const COL_H_INDEX = 7;
            const COL_W_INDEX = 22;
            const COL_Y_INDEX = 24;
            const COL_Z_INDEX = 25;
            const PREFIX_TO_REMOVE = "Unidad Responsable*: ";

            // 1. Unificar columnas H y Y en Z
            data.forEach((row, index) => {
                if (index === 0) { // Fila de encabezado
                    row[COL_Z_INDEX] = "Unidad Responsable (Unificada)";
                    return;
                }

                const valH = row[COL_H_INDEX];
                const valY = row[COL_Y_INDEX];

                if (valH && String(valH).trim() !== '') {
                    row[COL_Z_INDEX] = valH;
                } else if (valY && String(valY).trim() !== '') {
                    row[COL_Z_INDEX] = String(valY).replace(PREFIX_TO_REMOVE, '').trim();
                } else {
                    row[COL_Z_INDEX] = null;
                }
            });

            // 2. Eliminar columnas W, Y, H (en orden inverso para no afectar los índices)
            data.forEach(row => {
                row.splice(COL_Y_INDEX, 1); // Eliminar Y
                row.splice(COL_W_INDEX, 1); // Eliminar W
                row.splice(COL_H_INDEX, 1); // Eliminar H
            });

            // 3. Crear un nuevo libro de trabajo con la hoja modificada
            const newWs = XLSX.utils.aoa_to_sheet(data);
            wb.Sheets[sheetName] = newWs;
            return wb;
        }

        // === STEP 1: CONSOLIDATE WORKBOOKS ===
        async function runStep1() {
            setLoading(1, true);
            log("Iniciando Paso 1: Unificando todos los libros...");
            
            // Allow UI to render loader
            await new Promise(r => setTimeout(r, 100));

            try {
                // Create a new master workbook
                const masterWb = XLSX.utils.book_new();
                const usedSheetNames = new Set();
                let filesProcessed = 0;
                let sheetsCopied = 0;

                for (const file of STATE.zipFiles) {
                    try {
                        // Read the excel file from buffer
                        const wb = XLSX.read(file.data, { type: 'array' });
                        
                        wb.SheetNames.forEach(sheetName => {
                            // REQUERIMIENTO: Ignorar hojas que empiezan con "FID"
                            if (sheetName.toUpperCase().startsWith('FID')) {
                                log(`Omitiendo hoja '${sheetName}' del archivo '${file.fileNameSimple}' porque empieza con 'FID'.`);
                                return; // Saltar esta hoja
                            }

                            let ws = wb.Sheets[sheetName];
                            
                            // Handle duplicate names (Requerimiento: "conservando su nombre original (no se repiten y debe verificar que no lo hagan)")
                            let uniqueName = sheetName;
                            let counter = 1;
                            while (usedSheetNames.has(uniqueName)) {
                                uniqueName = `${sheetName}_${counter}`;
                                counter++;
                            }
                            usedSheetNames.add(uniqueName);

                            // Add to master workbook
                            XLSX.utils.book_append_sheet(masterWb, ws, uniqueName);
                            sheetsCopied++;
                        });
                        filesProcessed++;
                        // Log progress every 5 files to not spam
                        if (filesProcessed % 5 === 0) log(`Procesados ${filesProcessed}/${STATE.zipFiles.length} archivos...`);
                        
                    } catch (err) {
                        log(`Error leyendo ${file.name}: ${err.message}`, 'error');
                    }
                }

                STATE.wbStep1 = masterWb;
                
                log(`Paso 1 Completado. Libros: ${filesProcessed}, Hojas totales: ${sheetsCopied}`, 'success');
                setLoading(1, false);
                enableStep(2);
                document.getElementById('dlStep1').classList.remove('hidden');

            } catch (e) {
                log("Error crítico en Paso 1: " + e.message, 'error');
                setLoading(1, false);
            }
        }

        // === STEP 2: PRE-PROCESS SHEETS (THE NEW STEP 1.1) ===
        async function runStep2() {
            setLoading(2, true);
            log("Iniciando Paso 2: Pre-procesando hojas (limpieza y formato relacional)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep1) throw new Error("Falta el resultado del Paso 1");

                // Create a new workbook for the results of this step
                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of STATE.wbStep1.SheetNames) {
                    const ws = STATE.wbStep1.Sheets[sheetName];

                    if (sheetName.toLowerCase().startsWith('ramo')) {
                        // If sheet name starts with "Ramo", copy it as is
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        log(`Hoja '${sheetName}' omitida del pre-proceso (comienza con 'Ramo').`);
                        continue;
                    }

                    // Convert sheet to array of arrays
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

                    // 1. Delete first 3 rows
                    data.splice(0, 3);

                    // 2. Find metadata
                    let metadata = {
                        programa: '',
                        ramo: '',
                        unidad: '',
                        enfoque: '',
                        presupuestoOriginal: { meta: '', ejercido: '', pct: '' },
                        presupuestoModificado: { meta: '', ejercido: '', pct: '' }
                    };
                    let headerRowsToDelete = 0;

                    // 3. Find and delete "PRESUPUESTO" title row
                    const presupuestoTitleIndex = data.findIndex(row => 
                        String(row[0]).trim() === "PRESUPUESTO" && row.slice(1).every(c => c === null)
                    );
                    if (presupuestoTitleIndex > -1) {
                        data.splice(presupuestoTitleIndex, 1);
                    }

                    // 4. Extract data and find how many header rows to delete
                    let lastHeaderRowIndex = -1;
                    data.forEach((row, index) => {
                        const keyColA = String(row[0] || '').trim().replace(/\s+/g, ' '); // Clave principal en Columna A
                        
                        if (keyColA.startsWith("Programa presupuestario")) { metadata.programa = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Ramo")) { metadata.ramo = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Unidad responsable")) { metadata.unidad = row[3] ?? ''; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Enfoques transversales")) { metadata.enfoque = row[3] ?? ''; lastHeaderRowIndex = index; }
                        
                        // Condición fortalecida: busca "PRESUPUESTO ORIGINAL" y verifica que la cabecera "Meta anual" esté 2 filas arriba en la columna E.
                        if (keyColA.startsWith("PRESUPUESTO ORIGINAL") && index >= 2 && String(data[index - 2][4] || '').trim() === "Meta anual") {
                            metadata.presupuestoOriginal = { meta: row[4] ?? '', ejercido: row[5] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        }
                        // Condición fortalecida: busca "PRESUPUESTO MODIFICADO" y verifica que la cabecera "Meta anual" esté 3 filas arriba en la columna E.
                        if (keyColA.startsWith("PRESUPUESTO MODIFICADO") && index >= 3 && String(data[index - 3][4] || '').trim() === "Meta anual") {
                            metadata.presupuestoModificado = { meta: row[4] ?? '', ejercido: row[5] ?? '', pct: row[6] ?? '' };
                            lastHeaderRowIndex = index;
                        }
                    });

                    // 5. Delete all header rows up to the last one found
                    if (lastHeaderRowIndex > -1) {
                        data.splice(0, lastHeaderRowIndex + 2); // +2 para eliminar también la fila de encabezados de la tabla
                    }

                    // 6. Add new headers and data
                    if (data.length > 0) {
                        // Add headers to the first row of data
                        const headers = [
                            "Programa Presupuestario", "Ramo", "Unidad Responsable", "Enfoque Transversal",
                            "PO Meta Anual", "PO Ejercido", "PO % Anual",
                            "PM Meta Anual", "PM Ejercido", "PM % Anual"
                        ];
                        headers.forEach((h, i) => data[0][10 + i] = h); // Start at column K (index 10)

                        // Add data to all subsequent rows
                        const values = [
                            metadata.programa, metadata.ramo, metadata.unidad, metadata.enfoque,
                            metadata.presupuestoOriginal.meta, metadata.presupuestoOriginal.ejercido, metadata.presupuestoOriginal.pct,
                            metadata.presupuestoModificado.meta, metadata.presupuestoModificado.ejercido, metadata.presupuestoModificado.pct
                        ];
                        for (let i = 1; i < data.length; i++) {
                            values.forEach((v, j) => data[i][10 + j] = v);
                        }
                    }

                    // Create a new worksheet with the transformed data
                    const newWs = XLSX.utils.aoa_to_sheet(data);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep2 = processedWb;
                log(`Paso 2 Completado. Se pre-procesaron ${processedCount} hojas.`, 'success');
                setLoading(2, false);
                enableStep(3);
                document.getElementById('dlStep2').classList.remove('hidden');
            } catch (e) {
                log("Error en Paso 2: " + e.message, 'error');
                setLoading(2, false);
            }
        }

        // === STEP 3: EXTRACT MORE METADATA (EJE, PROGRAMA, ETC.) ===
        async function runStep3() {
            setLoading(3, true);
            log("Iniciando Paso 3: Extrayendo metadatos adicionales (Eje, Programa, etc.)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep2) throw new Error("Falta el resultado del Paso 2");

                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of STATE.wbStep2.SheetNames) {
                    const ws = STATE.wbStep2.Sheets[sheetName];

                    if (sheetName.toLowerCase().startsWith('ramo')) {
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        log(`Hoja '${sheetName}' omitida de la extracción de metadatos (comienza con 'Ramo').`);
                        continue;
                    }

                    // --- INICIO: Lógica de extracción de Nivel/Unidad (CORREGIDA) ---
                    // Esta lógica ahora se ejecuta ANTES de la transformación de indicadores.
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });
                    const rowsToDelete = new Set(); // Declaración movida aquí para que esté disponible para toda la función.
                    
                    // Find the header row from Step 2. It's the first row that has "Programa Presupuestario" in column K (index 10)
                    const headerRowIndex = data.findIndex(row => (row[10] || '') === "Programa Presupuestario");

                    const resultadosIndex = data.findIndex(row => String(row[0] || '').trim() === "RESULTADOS");

                    if (resultadosIndex > -1) {

                        const sectionToEnd = data.slice(resultadosIndex + 1);
                        const hasNivel = sectionToEnd.some(row => String(row[0] || '').trim().startsWith("NIVEL:"));
                        
                        let newHeadersAdded = false;
                        const stopTexts = [
                            "Justificación de diferencia de avances con respecto a las metas programadas",
                            "Justificación del ajuste a las metas"
                        ];

                        rowsToDelete.add(resultadosIndex); // Marcar "RESULTADOS" para eliminar

                        if (hasNivel) { // --- MODO NIVEL ---
                            log(`- Hoja '${sheetName}' en 'Modo Nivel'.`);
                            let nivelActual = '';
                            for (let i = resultadosIndex + 1; i < data.length; i++) {
                                const key = String(data[i][0] || '').trim();
                                if (stopTexts.includes(key)) break; // Detenerse si se encuentra texto de justificación

                                if (key.startsWith("NIVEL:")) {
                                    nivelActual = key;
                                    rowsToDelete.add(i);
                                } else if (!rowsToDelete.has(i)) {
                                    if (!newHeadersAdded && headerRowIndex > -1) {
                                        data[headerRowIndex][28] = "NIVEL";
                                        newHeadersAdded = true;
                                    }
                                    data[i][28] = nivelActual;
                                }
                            }
                        } else { // --- MODO UNIDAD ---
                            log(`- Hoja '${sheetName}' en 'Modo Unidad'.`);
                            let unidadActual = '';
                            for (let i = resultadosIndex + 1; i < data.length; i++) {
                                const key = String(data[i][0] || '').trim();
                                if (stopTexts.includes(key)) break; // Detenerse si se encuentra texto de justificación

                                if (key.startsWith("Unidad Responsable*:")) {
                                    unidadActual = key;
                                    rowsToDelete.add(i);
                                } else if (!rowsToDelete.has(i)) {
                                    if (!newHeadersAdded && headerRowIndex > -1) {
                                        data[headerRowIndex][29] = "Unidad Responsable";
                                        newHeadersAdded = true;
                                    }
                                    data[i][29] = unidadActual;
                                }
                            }
                        }
                    }
                    // --- FIN: Lógica de extracción de Nivel/Unidad (CORREGIDA) ---


                    // --- INICIO: Lógica de transformación de indicadores (Paso 3.1) ---
                    // let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null }); // Movido arriba
                    if (data.length === 0) {
                        XLSX.utils.book_append_sheet(processedWb, XLSX.utils.aoa_to_sheet([]), sheetName);
                        continue;
                    }

                    // --- INICIO: Lógica de transformación de indicadores (Refactorizada) ---
                    const indicadoresIndex = data.findIndex(row => String(row[0] || '').trim() === "INDICADORES");
                    if (indicadoresIndex > -1) {
                        const indicatorRows = data.slice(indicadoresIndex + 1);
                        const consolidatedIndicators = [];
                        let currentBlock = [];

                        for (const row of indicatorRows) {
                            const cellA = String(row[0] || '').trim();
                            // Si encontramos "DENOMINACIÓN" y el bloque actual no está vacío, procesamos el bloque anterior.
                            if (cellA === "DENOMINACIÓN" && currentBlock.length > 0) {
                                const consolidatedRow = processIndicatorBlock(currentBlock);
                                if (consolidatedRow) consolidatedIndicators.push(consolidatedRow);
                                currentBlock = []; // Empezamos un nuevo bloque
                            }
                            currentBlock.push(row);
                        }
                        // Procesar el último bloque
                        if (currentBlock.length > 0) {
                            const consolidatedRow = processIndicatorBlock(currentBlock);
                            if (consolidatedRow) consolidatedIndicators.push(consolidatedRow);
                        }

                        // Reemplazar las filas de indicadores originales con las nuevas filas consolidadas
                        data.splice(indicadoresIndex, data.length - indicadoresIndex, ...consolidatedIndicators);
                    }

                    function processIndicatorBlock(block) {
                        if (!block || block.length === 0) return null;

                        let baseRow = undefined;
                        const pivotedValues = {
                            aprobada: undefined,
                            ajustada: undefined,
                            realizado: undefined,
                            avance: undefined
                        };

                        // 1. Encontrar la fila base, que es la que contiene el nombre del indicador.
                        // Esta suele estar después de una o más filas "DENOMINACIÓN".
                        let lastRowWasDenominacion = false;
                        for (const row of block) {
                            const cellA = String(row[0] || '').trim();
                            if (cellA === "DENOMINACIÓN") {
                                lastRowWasDenominacion = true;
                            } else if (lastRowWasDenominacion && cellA !== "") {
                                baseRow = [...row]; // Encontramos la fila con el nombre, la copiamos.
                                break; // Salimos del bucle una vez encontrada.
                            }
                        }

                        // Si no encontramos una fila base (nombre del indicador), no podemos consolidar.
                        if (!baseRow) return null;

                        // --- INICIO: Mejora para corregir columnas desfasadas ---
                        // En algunas hojas, no hay "OBJETIVOS", por lo que "MÉTODO" está en B y "UNIDAD" en C.
                        // La cabecera "DENOMINACIÓN" está en la primera fila del bloque.
                        const headerRow = block[0];
                        const unidadMedidaInColC = String(headerRow[2] || '').trim() === "UNIDAD DE MEDIDA";

                        if (unidadMedidaInColC) {
                            // Mover C -> D, B -> C, y dejar B vacío.
                            baseRow[3] = baseRow[2]; // Unidad de Medida
                            baseRow[2] = baseRow[1]; // Método de Cálculo
                            baseRow[1] = null;       // Objetivos (vacío)
                        }
                        // --- FIN: Mejora para corregir columnas desfasadas ---

                        // 2. Recorrer todo el bloque para capturar todos los valores a pivotar.
                        for (const row of block) {
                            const keyF = String(row[5] || '').trim();
                            if (keyF.startsWith("Meta anual aprobada")) { pivotedValues.aprobada = row[6]; }
                            if (keyF.startsWith("Meta anual ajustada")) { pivotedValues.ajustada = row[6]; }
                            if (keyF.startsWith("Realizado al Período")) { pivotedValues.realizado = row[6]; }
                            if (keyF.startsWith("Avance realizado al período")) { pivotedValues.avance = row[6]; }
                        }

                        // 3. Asignar los valores capturados a las nuevas columnas en la fila base.
                        baseRow[31] = pivotedValues.aprobada;
                        baseRow[32] = pivotedValues.ajustada;
                        baseRow[33] = pivotedValues.realizado;
                        baseRow[34] = pivotedValues.avance;

                        return baseRow;
                    }
                    // --- FIN: Lógica de transformación de indicadores ---

                    let metadata = {
                        eje: '', programa: '', objetivo: '',
                        finalidad: '', funcion: '', subfuncion: '', actividad: ''
                    };

                    if (headerRowIndex === -1) {
                        log(`Advertencia en '${sheetName}': No se encontró la fila de encabezados del Paso 2. La hoja podría no procesarse correctamente.`, 'error');
                    }

                    // Scan for metadata and mark rows for deletion
                    for (let i = 0; i < data.length; i++) {
                        // No procesar la sección de indicadores que ya fue transformada
                        if (indicadoresIndex > -1 && i >= indicadoresIndex) {
                            break;
                        }

                        const row = data[i];
                        const key = String(row[0] || '').trim().replace(/\s+/g, ' ');
                        const nextRow = data[i + 1];

                        if (key === "Eje" && nextRow) {
                            metadata.eje = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i);
                            rowsToDelete.add(i + 1);
                        }
                        if (key === "Programa" && nextRow) {
                            metadata.programa = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i);
                            rowsToDelete.add(i + 1);
                        }
                        if (key === "Objetivo Prioritario" && nextRow) {
                            metadata.objetivo = String(nextRow[0] ?? '').trim();
                            rowsToDelete.add(i); // Marcar "Objetivo Prioritario"
                            rowsToDelete.add(i + 1); // Marcar el valor del objetivo

                            // Buscar desde aquí hasta encontrar "CLASIFICACIÓN FUNCIONAL" o "RESULTADOS"
                            for (let j = i + 2; j < data.length; j++) {
                                const subKey = String(data[j][0] || '').trim();
                                if (subKey === "CLASIFICACIÓN FUNCIONAL" || subKey === "RESULTADOS") {
                                    break; // Detenerse al encontrar el siguiente bloque importante
                                }
                                rowsToDelete.add(j); // Marcar para eliminar las filas intermedias
                            }
                        }

                        if (key === "Finalidad") { metadata.finalidad = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Función") { metadata.funcion = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Subfunción") { metadata.subfuncion = String(row[2] ?? '').trim(); rowsToDelete.add(i); }
                        if (key === "Actividad Institucional") { metadata.actividad = String(row[2] ?? '').trim(); rowsToDelete.add(i); }

                        // Mark title/empty rows for deletion
                        if (key.includes("ALINEACIÓN CON LOS EJES") || key.includes("Alineación con los Programas") || key === "CLASIFICACIÓN FUNCIONAL") rowsToDelete.add(i);

                        // Eliminar la fila "Fichas de Indicadores del Desempeño" si las columnas B-G están vacías.
                        if (key === "Fichas de Indicadores del Desempeño") {
                            const colsBtoG = row.slice(1, 7); // Columnas B a G
                            const areColsEmpty = colsBtoG.every(cell => cell === null || String(cell).trim() === '');
                            if (areColsEmpty) rowsToDelete.add(i);
                        }

                        if (row.every(cell => cell === null || cell === '')) rowsToDelete.add(i);
                    }

                    // --- INICIO: Lógica 3.1 Fortalecida ---
                    let fidNote = '';
                    const textoInicioNota = "*Los Programas presupuestarios pueden ser ejecutados de manera conjunta por diversas";
                    // Revisar las últimas 5 filas, que es donde suele estar la nota.
                    for (let i = Math.max(0, data.length - 5); i < data.length; i++) {
                        const cellText = String(data[i][0] || '').trim();
                        if (cellText.startsWith(textoInicioNota)) {
                            fidNote = cellText; // Capturar el texto completo de la celda
                            rowsToDelete.add(i); // Marcar para eliminar de su posición original
                            break; // Salir una vez encontrada
                        }
                    }

                    // Búsqueda de cualquiera de los dos textos de justificación
                    const justificacionIndex = data.findIndex(row => {
                        const cellText = String(row[0] || '').trim();
                        return cellText === "Justificación de diferencia de avances con respecto a las metas programadas" ||
                               cellText === "Justificación del ajuste a las metas";
                    });

                    if (justificacionIndex > -1) {
                        let denominacionFound = false;
                        for (let i = justificacionIndex + 1; i < data.length; i++) {
                            if (String(data[i][0] || '').trim().includes("DENOMINACIÓN")) {
                                denominacionFound = true;
                                break;
                            }
                        }
                        if (!denominacionFound) {
                            for (let i = justificacionIndex; i < data.length; i++) {
                                rowsToDelete.add(i);
                            }
                        }
                    }
                    // --- FIN: Lógica 3.1 Fortalecida ---

                    // Filter out the marked rows
                    let cleanedData = data.filter((_, index) => {
                        // Mantener la fila de encabezado, y eliminar las filas marcadas por ambas lógicas de borrado
                        return index === headerRowIndex || !rowsToDelete.has(index);
                    });

                    // Add new headers and data
                    if (cleanedData.length > 0) {
                        const headers = [
                            "Eje", "Programa", "Objetivo Prioritario",
                            "Finalidad", "Función", "Subfunción", "Actividad Institucional"
                        ];
                        const fidHeaderIndex = 30; // Colocamos FID en la columna AE (índice 30)

                        // Start at column U (index 20)
                        headers.forEach((h, i) => cleanedData[0][20 + i] = h);
                        if (fidNote) cleanedData[0][fidHeaderIndex] = "FID"; // Añadir encabezado FID solo si se encontró la nota

                        // Añadir encabezados de pivote
                        if (indicadoresIndex > -1) {
                            // CORRECCIÓN: Asegurar que los encabezados de A-E se mantengan en la fila 0.
                            // La lógica de `processIndicatorBlock` puede haber reemplazado la fila de encabezado.
                            const headerRow = cleanedData[0];
                            headerRow[0] = "DENOMINACIÓN";
                            headerRow[1] = "OBJETIVOS";
                            headerRow[2] = "MÉTODO DE CÁLCULO";
                            headerRow[3] = "UNIDAD DE MEDIDA";
                            headerRow[4] = "TIPO-DIMENSIÓN-FRECUENCIA";
                            // Encabezados de Metas a partir de AF (índice 31)
                            const pivotHeaders = [
                                "Meta Anual Aprobada",
                                "Meta Anual Ajustada",
                                "Realizado al Período",
                                "Avance %"
                            ];
                            pivotHeaders.forEach((h, i) => headerRow[31 + i] = h);
                        }

                        const values = [
                            metadata.eje, metadata.programa, metadata.objetivo,
                            metadata.finalidad, metadata.funcion, metadata.subfuncion, metadata.actividad
                        ];
                        for (let i = 1; i < cleanedData.length; i++) {
                            values.forEach((v, j) => cleanedData[i][20 + j] = v);
                            if (fidNote) cleanedData[i][fidHeaderIndex] = fidNote; // Añadir el valor de la nota a cada fila
                        }
                    }

                    // --- INICIO: Lógica de limpieza final del Paso 3 ---
                    // 1. Verificar si la segunda fila es "Primera Cadena de Alineación" y eliminarla.
                    if (cleanedData.length > 1 && String(cleanedData[1][0] || '').trim() === "Primera Cadena de Alineación") {
                        cleanedData.splice(1, 1);
                    }

                    // 2. Eliminar filas donde las columnas A-G están vacías (excepto la cabecera).
                    cleanedData = cleanedData.filter((row, index) => {
                        if (index === 0) return true; // Siempre mantener la fila de encabezado.
                        const firstSevenCols = row.slice(0, 7);
                        return firstSevenCols.some(cell => cell !== null && cell !== undefined && String(cell).trim() !== '');
                    });

                    // 3. Eliminar las columnas F, G, H, I, J (índices 5, 6, 7, 8, 9).
                    // Esto se hace en cada fila. El método splice(5, 5) elimina 5 elementos a partir del índice 5.
                    cleanedData.forEach(row => {
                        if (row.length > 9) { // Asegurarse de que la fila tenga suficientes columnas para evitar errores.
                            row.splice(5, 5);
                        }
                    });
                    // --- FIN: Lógica de limpieza final del Paso 3 ---

                    const newWs = XLSX.utils.aoa_to_sheet(cleanedData);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep3 = processedWb;
                log(`Paso 3 Completado. Se extrajeron metadatos de ${processedCount} hojas.`, 'success');
                setLoading(3, false);
                enableStep('3_1');
                document.getElementById('dlStep3').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 3: " + e.message, 'error');
                setLoading(3, false);
            }
        }

        // === STEP 3.1: CLEAN "RAMO" SHEETS ===
        async function runStep3_1() {
            setLoading('3_1', true);
            log("Iniciando Paso 3.1: Limpiando hojas 'Ramo'...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep3) throw new Error("Falta el resultado del Paso 3");

                const sourceWb = STATE.wbStep3;
                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of sourceWb.SheetNames) {
                    const ws = sourceWb.Sheets[sheetName];

                    // Solo procesar hojas "Ramo"
                    if (!sheetName.toLowerCase().startsWith('ramo')) {
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName); // Copiar las otras hojas sin cambios
                        continue;
                    }

                    log(`Procesando hoja 'Ramo': ${sheetName}`);
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

                    // 1. Buscar la fila de cabecera "Clave Programa presupuestario" en la columna B (índice 1)
                    const headerRowIndex = data.findIndex(row => String(row[1] || '').trim() === "Clave Programa presupuestario");

                    if (headerRowIndex === -1) {
                        log(`Advertencia: No se encontró la cabecera 'Clave Programa presupuestario' en la hoja ${sheetName}. Se copiará sin cambios.`, 'error');
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        continue;
                    }

                    // 2. Eliminar todas las filas anteriores a la cabecera
                    if (headerRowIndex > 0) {
                        data.splice(0, headerRowIndex);
                        log(`- Se eliminaron ${headerRowIndex} filas de cabecera.`);
                    }

                    // 3. Eliminar la columna A (índice 0) de cada fila
                    data.forEach(row => row.splice(0, 1));
                    log(`- Se eliminó la columna A.`);

                    // 4. Rellenar vacíos (lógica similar al Paso 6) en las primeras 6 columnas nuevas (ex B-G)
                    const NUM_COLS_TO_FILL = 6; // A-F
                    let lastValues = new Array(NUM_COLS_TO_FILL).fill(null);
                    let filledCount = 0;

                    for (let r = 1; r < data.length; r++) { // Empezar desde la fila 1 (después de la cabecera)
                        for (let c = 0; c < NUM_COLS_TO_FILL; c++) {
                            const cellValue = data[r][c];
                            if (cellValue === null || String(cellValue).trim() === '') {
                                if (lastValues[c] !== null) {
                                    data[r][c] = lastValues[c];
                                    filledCount++;
                                }
                            } else {
                                lastValues[c] = cellValue;
                            }
                        }
                    }
                    log(`- Se rellenaron ${filledCount} celdas vacías en las primeras 6 columnas.`);

                    const newWs = XLSX.utils.aoa_to_sheet(data);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep3_1 = processedWb;
                log(`Paso 3.1 Completado. Se limpiaron ${processedCount} hojas 'Ramo'.`, 'success');
                setLoading('3_1', false);
                enableStep(4);
                document.getElementById('dlStep3_1').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 3.1: " + e.message, 'error');
                setLoading('3_1', false);
            }
        }

        // === STEP 4: CONSOLIDATE SHEETS (A:T + Label in U) ===
        async function runStep4() {
            setLoading(4, true);
            log("Iniciando Paso 4: Consolidando hojas en dos grupos (Ramo y General)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep3_1) throw new Error("Falta el resultado del Paso 3.1");

                const sourceWb = STATE.wbStep3_1;
                const destWb = XLSX.utils.book_new();

                let ramoData = [];
                let generalData = [];
                const DEST_SHEET_RAMO = "CONSOLIDADO_RAMO";
                const DEST_SHEET_GENERAL = "CONSOLIDADO_GENERAL";

                sourceWb.SheetNames.forEach(sheetName => {
                    const ws = sourceWb.Sheets[sheetName];
                    const data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

                    if (data.length === 0) return;

                    const targetArray = sheetName.toLowerCase().startsWith('ramo') ? ramoData : generalData;

                    // Si es la primera vez que agregamos datos a este grupo, añadimos la cabecera.
                    if (targetArray.length === 0 && data.length > 0) {
                        // La primera fila de 'data' es la cabecera del paso 3.
                        const headerRow = data[0];
                        headerRow.push("NOMBRE_HOJA_ORIGEN");
                        targetArray.push(headerRow);
                    }

                    // Añadir el nombre de la hoja a cada fila (excepto la de cabecera).
                    data.forEach((row, index) => {
                        // Omitir la fila de cabecera (index 0) y las filas completamente vacías.
                        if (index > 0) {
                            // MEJORA: Una fila se considera vacía si no tiene un valor significativo.
                            // Para las hojas 'Ramo', la columna G (índice 6, "Original Aprobado") debe tener un valor.
                            // Para las hojas generales, la columna A (índice 0, "DENOMINACIÓN") debe tener un valor.
                            const isRamoSheet = sheetName.toLowerCase().startsWith('ramo');
                            const significantCellIndex = isRamoSheet ? 6 : 0; // Col G para Ramo, Col A para General
                            const significantCell = row[significantCellIndex];
                            const isRowEffectivelyEmpty = significantCell === "" || significantCell === null || significantCell === undefined;
                            
                            if (!isRowEffectivelyEmpty) {
                                const dataRow = row;
                                dataRow.push(sheetName); // Añadir el nombre de la hoja origen
                                targetArray.push(dataRow);
                            }
                        }
                    });
                });

                // Create and append sheets if they have data
                if (ramoData.length > 0) {
                    const newWsRamo = XLSX.utils.aoa_to_sheet(ramoData);
                    XLSX.utils.book_append_sheet(destWb, newWsRamo, DEST_SHEET_RAMO);
                    log(`- Grupo 'Ramo': ${ramoData.length} filas generadas en la hoja '${DEST_SHEET_RAMO}'.`);
                } else {
                    log("- Grupo 'Ramo': No se encontraron hojas que comenzaran con 'Ramo'.");
                }

                if (generalData.length > 0) {
                    const newWsGeneral = XLSX.utils.aoa_to_sheet(generalData);
                    XLSX.utils.book_append_sheet(destWb, newWsGeneral, DEST_SHEET_GENERAL);
                    log(`- Grupo 'General': ${generalData.length} filas generadas en la hoja '${DEST_SHEET_GENERAL}'.`);
                } else {
                    log("- Grupo 'General': No se encontraron hojas que no comenzaran con 'Ramo'.");
                }

                // The next step (unmerge) needs to know which sheet to process.
                // The macro seems to imply the main consolidation is the non-Ramo one.
                // Let's rename the general one to the original name for compatibility with next steps.
                if (destWb.Sheets[DEST_SHEET_GENERAL]) {
                    destWb.Sheets["CONSOLIDADO_TOTAL"] = destWb.Sheets[DEST_SHEET_GENERAL];
                    delete destWb.Sheets[DEST_SHEET_GENERAL];
                    destWb.SheetNames[destWb.SheetNames.indexOf(DEST_SHEET_GENERAL)] = "CONSOLIDADO_TOTAL";
                }

                STATE.wbStep4 = destWb;
                log(`Paso 4 Completado. Se crearon ${destWb.SheetNames.length} hojas consolidadas.`, 'success');
                setLoading(4, false);
                enableStep(5);
                document.getElementById('dlStep4').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 4: " + e.message, 'error');
                setLoading(4, false);
            }
        }

        // === STEP 5: UNMERGE ALL ===
        async function runStep5() {
            // ADVERTENCIA: Este paso y los siguientes (4 y 5) operarán sobre la hoja "CONSOLIDADO_TOTAL".
            // La hoja "CONSOLIDADO_RAMO" no será modificada por los pasos posteriores.
            // Esto replica el comportamiento más probable de la macro original, que se enfoca en un solo flujo de datos.

            setLoading(5, true);
            log("Iniciando Paso 5: Descombinando celdas...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep4) throw new Error("Falta el resultado del Paso 4");
                
                // Clone workbook logic (SheetJS objects are references, so we should be careful)
                // Since we are moving forward, we can modify the previous WB or clone data.
                // Simplest: Write to buffer and read back to deep clone, or just modify the object if we don't care about history.
                // Let's modify object directly but save as new reference in state for clarity.
                
                const wb = STATE.wbStep4; // We will modify this directly effectively
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"]; // This is the target sheet

                if (!ws) {
                    log("No se encontró la hoja 'CONSOLIDADO_TOTAL' para descombinar. Saltando paso.", 'error');
                    throw new Error("Hoja 'CONSOLIDADO_TOTAL' no encontrada.");
                }
                
                // Unmerge logic in SheetJS: simply delete the '!merges' property
                if (ws['!merges']) {
                    const count = ws['!merges'].length;
                    delete ws['!merges'];
                    log(`Se eliminaron ${count} configuraciones de fusión de celdas.`);
                } else {
                    log("No se encontraron celdas combinadas.");
                }

                STATE.wbStep5 = wb; // Pointer to same object (modified)
                
                log("Paso 5 Completado.", 'success');
                setLoading(5, false);
                enableStep(6);
                document.getElementById('dlStep5').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 5: " + e.message, 'error');
                setLoading(5, false);
            }
        }

        // === STEP 6: FILL BLANKS (Column A-F) ===
        async function runStep6() {
            setLoading(6, true);
            log("Iniciando Paso 6: Rellenando vacíos en Columnas A-F...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep5) throw new Error("Falta el resultado del Paso 5");
                if (!STATE.wbStep5.Sheets["CONSOLIDADO_TOTAL"]) {
                    log("No se encontró la hoja 'CONSOLIDADO_TOTAL' para rellenar. Saltando paso.", 'error');
                    throw new Error("Hoja 'CONSOLIDADO_TOTAL' no encontrada.");
                }

                const wb = STATE.wbStep4;
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"];
                
                // Get range
                const range = XLSX.utils.decode_range(ws['!ref']);
                const NUM_COLS_TO_FILL = 6; // A=0, B=1, C=2, D=3, E=4, F=5
                let lastValues = new Array(NUM_COLS_TO_FILL).fill(null);
                let filledCount = 0;

                // Loop through each row
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    // Loop through columns A to F
                    for (let C = 0; C < NUM_COLS_TO_FILL; ++C) {
                        const cellRef = XLSX.utils.encode_cell({c: C, r: R});
                        const cell = ws[cellRef];

                        // Check if cell is empty or has no value
                        if (!cell || cell.v === undefined || cell.v === "") {
                            // If it's empty but we have a last known value for this column, fill it
                            if (lastValues[C] !== null) {
                                ws[cellRef] = { v: lastValues[C], t: 's' }; // Use 's' for string type
                                filledCount++;
                            }
                        } else {
                            // If cell has a value, update the last known value for this column
                            lastValues[C] = cell.v;
                        }
                    }
                }

                // --- INICIO: Lógica agregada para filtrar y marcar "FID" ---
                log("Iniciando búsqueda de texto para marcar 'FID' en columna I...");
                const textoBusqueda = "Los Programas presupuestarios pueden ser ejecutados de manera conjunta por diversas Unidades Responsables para el cumplimiento de sus objetivos y metas. Para fines de recolección de la información del logro de los objetivos y metas establecidos en la Ficha de Indicadores del Desempeño (FID), en los reportes se asocia a una o más Unidades Responsables, que no necesariamente representan la totalidad de ellas. Por ello, para facilitar la identificación de las Unidades Responsables, se puede consultar el Estado Analítico del Ejercicio del Presupuesto de Egresos en Clasificación Funcional-Programática de cada Ramo en la Cuenta Pública 2024.";
                let fidCount = 0;

                // Recorrer filas nuevamente para buscar el texto en la columna A
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    const cellRefA = XLSX.utils.encode_cell({c: 0, r: R}); // Columna A
                    const cellA = ws[cellRefA];

                    // Normalizar el texto de la celda para una comparación robusta
                    const cellValue = (cellA && cellA.v) ? String(cellA.v).trim().replace(/\s+/g, ' ') : "";
                    const targetValue = textoBusqueda.replace(/\s+/g, ' ');

                    if (cellValue === targetValue) {
                        const cellRefI = XLSX.utils.encode_cell({c: 8, r: R}); // Columna I
                        
                        // Crear o actualizar la celda en la columna I
                        ws[cellRefI] = { v: "FID", t: 's' };
                        fidCount++;
                    }
                }

                if (fidCount > 0) {
                    log(`Se marcaron ${fidCount} filas con 'FID' en la columna I.`, 'success');
                }
                // --- FIN: Lógica agregada ---

                STATE.wbStep6 = wb;
                
                log(`Paso 6 Completado. Se rellenaron ${filledCount} celdas y se marcaron ${fidCount} filas como FID.`, 'success');
                setLoading(6, false);
                document.getElementById('dlStep6').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 6: " + e.message, 'error');
                setLoading(6, false);
            }
        }

        // === STYLING UTILITY ===
        function applyStylesToWorkbook(wb) {
            const defaultFont = { name: 'Noto Sans', sz: 9 };
            const borderStyle = { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } };
            
            const headerStyleGeneral = {
                font: { name: 'Noto Sans', sz: 9, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "9C2348" } }, // Guinda
                border: borderStyle
            };
            const headerStyleRamo = {
                font: { name: 'Noto Sans', sz: 9, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "1E5B4F" } }, // Verde Oscuro
                border: borderStyle
            };
            const defaultCellStyle = {
                font: defaultFont,
                border: borderStyle
            };

            wb.SheetNames.forEach(sheetName => {
                const ws = wb.Sheets[sheetName];
                const range = XLSX.utils.decode_range(ws['!ref']);

                // Aplicar color a la pestaña de la hoja
                if (!ws['!props']) ws['!props'] = {};
                if (sheetName.includes("RAMO")) {
                    ws['!props'].tabColor = { rgb: "1E5B4F" }; // Verde Oscuro
                } else {
                    ws['!props'].tabColor = { rgb: "9C2348" }; // Guinda
                }

                // Iterar sobre todas las celdas para aplicar estilos
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = { c: C, r: R };
                        const cell_ref = XLSX.utils.encode_cell(cell_address);
                        let cell = ws[cell_ref];
                        if (!cell) cell = ws[cell_ref] = { t: 's', v: '' }; // Crear celda si no existe

                        // Aplicar estilo de encabezado a la primera fila
                        if (R === 0) {
                            if (sheetName.includes("RAMO")) {
                                cell.s = headerStyleRamo;
                            } else {
                                cell.s = headerStyleGeneral;
                            }
                        } else { // Aplicar estilo por defecto al resto
                            cell.s = defaultCellStyle;
                        }
                    }
                }
            });

            return wb;
        }

        // === UTILS ===
        function enableStep(num) {
            const card = document.getElementById(`cardStep${num}`);
            card.classList.remove('disabled');
            if (num == 2) document.getElementById('allInOneStep').classList.remove('hidden');
        }

        function setLoading(stepNum, isLoading) {
            const btn = document.querySelector(`#cardStep${stepNum} button`);
            if (isLoading) {
                btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Procesando...`;
                btn.disabled = true;
                btn.classList.add('opacity-75');
            } else {
                btn.innerHTML = `<span>Re-ejecutar</span>`;
                btn.disabled = false;
                btn.classList.remove('opacity-75');
            }
        }

        function downloadStep(stepNum) {
            let wb = null;
            let filename = "";
            
            switch(stepNum) {
                case 1: 
                    wb = STATE.wbStep1; 
                    filename = "1_Libros_Unificados.xlsx"; 
                    break;
                case 2: 
                    wb = STATE.wbStep2; 
                    filename = "2_PreProcesado.xlsx"; 
                    break;
                case 3: 
                    wb = STATE.wbStep3; 
                    filename = "3_Metadatos_Extraidos.xlsx"; 
                    break;
                case '3.1': 
                    wb = STATE.wbStep3_1; 
                    filename = "3_1_Ramo_Limpiado.xlsx"; 
                    break;
                case 4: 
                    wb = STATE.wbStep4; 
                    filename = "4_Hojas_Consolidadas.xlsx"; 
                    break;
                case 5: 
                    wb = STATE.wbStep5; 
                    filename = "5_Descombinado.xlsx"; 
                    break;
                case 6: 
                    wb = STATE.wbStep6; 
                    filename = "6_FINAL_Rellenado.xlsx"; 
                    break;
            }

            if (wb) {
                const styledWb = applyStylesToWorkbook(wb);
                XLSX.writeFile(styledWb, filename);
            }
        }
    </script>
</body>
</html>
