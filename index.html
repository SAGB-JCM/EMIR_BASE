<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consolidar Excel Automatizado</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Librerías Necesarias -->
    <!-- JSZip para manejar archivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- SheetJS (xlsx) para manipular Excel -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <!-- FontAwesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        .step-card {
            transition: all 0.3s ease;
        }
        .step-card.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(100%);
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans">

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        
        <!-- Header -->
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-blue-800 mb-2">
                <i class="fa-solid fa-file-excel mr-2"></i>Automatización de Consolidación
            </h1>
            <p class="text-gray-600">Procesa ZIPs, unifica Excels, consolida hojas y limpia datos (Réplica de Macros VBA)</p>
        </header>

        <!-- Input Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Opción 1: Subir Local -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-blue-500 transition-colors">
                    <i class="fa-solid fa-upload text-4xl text-gray-400 mb-4"></i>
                    <h3 class="font-bold mb-2">Opción A: Subir ZIP Local</h3>
                    <input type="file" id="fileInput" accept=".zip" class="hidden" onchange="handleFileUpload(this)">
                    <label for="fileInput" class="cursor-pointer bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition">
                        Seleccionar Archivo .zip
                    </label>
                </div>

                <!-- Opción 2: URL -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50">
                    <i class="fa-solid fa-globe text-4xl text-gray-400 mb-4 block text-center"></i>
                    <h3 class="font-bold mb-2 text-center">Opción B: URL (Hacienda)</h3>
                    <div class="flex gap-2">
                        <input type="text" id="urlInput" 
                            value="https://www.cuentapublica.hacienda.gob.mx/work/models/CP/2024/tomo/III/E_MIR.zip"
                            class="flex-1 border border-gray-300 rounded px-3 py-2 text-sm" placeholder="https://...">
                        <button onclick="handleUrlDownload()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition">
                            <i class="fa-solid fa-download"></i>
                        </button>
                    </div>
                    <p class="text-xs text-red-500 mt-2">Nota: Si la descarga falla por seguridad (CORS), descarga el ZIP manualmente y usa la Opción A.</p>
                </div>
            </div>
        </div>

        <!-- Log & Status Area -->
        <div id="statusArea" class="hidden bg-gray-900 text-green-400 font-mono text-sm p-4 rounded-lg mb-8 h-48 overflow-y-auto shadow-inner">
            <div id="logContent">Esperando archivo...</div>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="hidden mb-8">
            <h2 class="text-xl font-bold mb-4">Contenido del ZIP</h2>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="min-w-full">
                    <thead class="bg-gray-200 text-gray-700">
                        <tr>
                            <th class="py-2 px-4 text-left">Archivo</th>
                            <th class="py-2 px-4 text-left">Hojas Detectadas</th>
                            <th class="py-2 px-4 text-left">Estado</th>
                        </tr>
                    </thead>
                    <tbody id="fileListBody" class="text-sm">
                        <!-- Rows injected here -->
                    </tbody>
                </table>
            </div>
            <div class="mt-2 text-right text-sm text-gray-500">
                Total archivos Excel encontrados: <span id="totalFilesCount" class="font-bold">0</span>
            </div>
        </div>

        <!-- Processing Steps (Wizard) -->
        <div id="processingSteps" class="hidden grid grid-cols-1 md:grid-cols-5 gap-4">
            
            <!-- Step 1 -->
            <div id="cardStep1" class="step-card bg-white p-4 rounded-lg shadow border-l-4 border-blue-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 1</h3>
                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Consolidar Libros</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Une todos los archivos del ZIP en un solo libro de Excel.</p>
                <button onclick="runStep1()" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep1" onclick="downloadStep(1)" class="hidden mt-2 w-full border border-blue-600 text-blue-600 py-1 rounded hover:bg-blue-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 2 -->
            <div id="cardStep2" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-teal-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 2</h3>
                    <span class="text-xs bg-teal-100 text-teal-800 px-2 py-1 rounded">Pre-procesar Hojas</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Limpia y transforma hojas (no "Ramo") a formato relacional.</p>
                <button onclick="runStep2()" class="w-full bg-teal-600 text-white py-2 rounded hover:bg-teal-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep2" onclick="downloadStep(2)" class="hidden mt-2 w-full border border-teal-600 text-teal-600 py-1 rounded hover:bg-teal-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 3 -->
            <div id="cardStep3" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-purple-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 3</h3>
                    <span class="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">Consolidar Hojas</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Une columnas A:T de todas las hojas en una sola hoja maestra.</p>
                <button onclick="runStep3()" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep3" onclick="downloadStep(3)" class="hidden mt-2 w-full border border-purple-600 text-purple-600 py-1 rounded hover:bg-purple-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 4 -->
            <div id="cardStep4" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-orange-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 4</h3>
                    <span class="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">Descombinar</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Elimina celdas combinadas en la hoja consolidada.</p>
                <button onclick="runStep4()" class="w-full bg-orange-600 text-white py-2 rounded hover:bg-orange-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep4" onclick="downloadStep(4)" class="hidden mt-2 w-full border border-orange-600 text-orange-600 py-1 rounded hover:bg-orange-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar
                </button>
            </div>

            <!-- Step 5 -->
            <div id="cardStep5" class="step-card disabled bg-white p-4 rounded-lg shadow border-l-4 border-green-500">
                <div class="flex justify-between items-start mb-2">
                    <h3 class="font-bold text-lg">Paso 5</h3>
                    <span class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Rellenar Vacíos</span>
                </div>
                <p class="text-sm text-gray-600 mb-4">Rellena celdas vacías en Columnas A-F con el valor superior.</p>
                <button onclick="runStep5()" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700 transition flex justify-center items-center gap-2">
                    <span>Ejecutar</span>
                </button>
                <button id="dlStep5" onclick="downloadStep(5)" class="hidden mt-2 w-full border border-green-600 text-green-600 py-1 rounded hover:bg-green-50 text-sm">
                    <i class="fa-solid fa-download"></i> Descargar Final
                </button>
            </div>
        </div>

    </div>

    <!-- MAIN LOGIC SCRIPT -->
    <script>
        // === STATE MANAGEMENT ===
        const STATE = {
            zipFiles: [], // Array of objects { name, data (arraybuffer) }
            wbStep1: null, // The workbook object after Step 1
            wbStep2: null, // The workbook object after Step 2
            wbStep3: null, // The workbook object after Step 3
            wbStep4: null, // The workbook object after Step 4
            wbStep5: null  // The workbook object after Step 5
        };

        // === LOGGING UTILS ===
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('logContent');
            const color = type === 'error' ? 'text-red-500' : (type === 'success' ? 'text-green-300' : 'text-green-400');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div class="${color}">[${time}] ${msg}</div>`;
            document.getElementById('statusArea').scrollTop = document.getElementById('statusArea').scrollHeight;
        }

        // === FILE HANDLING ===
        async function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            processZip(file);
        }

        async function handleUrlDownload() {
            const url = document.getElementById('urlInput').value;
            // Usamos un proxy CORS gratuito para demos. En producción real, necesitarías tu propio backend.
            // allorigins.win o corsproxy.io son comunes.
            const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
            
            document.getElementById('statusArea').classList.remove('hidden');
            log(`Intentando descargar desde: ${url} ...`);
            log(`Usando proxy CORS para evadir restricciones de navegador...`);

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Error en descarga: ' + response.statusText);
                const blob = await response.blob();
                processZip(blob);
            } catch (error) {
                log(`Error: ${error.message}. Intenta descargar el archivo manualmente y usar la Opción A.`, 'error');
            }
        }

        async function processZip(blobOrFile) {
            document.getElementById('statusArea').classList.remove('hidden');
            document.getElementById('processingSteps').classList.add('hidden');
            document.getElementById('previewSection').classList.add('hidden');
            
            log("Abriendo archivo ZIP...");
            
            try {
                const zip = new JSZip();
                const contents = await zip.loadAsync(blobOrFile);
                
                STATE.zipFiles = [];
                const tableBody = document.getElementById('fileListBody');
                tableBody.innerHTML = '';
                let fileCount = 0;

                // Iterate through files in ZIP
                const promises = [];
                
                contents.forEach((relativePath, zipEntry) => {
                    // Filter for excel files, ignore MACOSX junk
                    if (!zipEntry.dir && !relativePath.includes('__MACOSX') && (relativePath.endsWith('.xls') || relativePath.endsWith('.xlsx'))) {
                        const p = zipEntry.async("arraybuffer").then(data => {
                            // Basic read to get sheet count without full parsing overhead if possible
                            // But SheetJS read is sync, so we wrap later.
                            STATE.zipFiles.push({
                                name: relativePath,
                                data: data,
                                fileNameSimple: relativePath.split('/').pop()
                            });
                        });
                        promises.push(p);
                    }
                });

                log(`Extrayendo ${promises.length} archivos Excel...`);
                await Promise.all(promises);

                STATE.zipFiles.forEach((file, index) => {
                    fileCount++;
                    const tr = document.createElement('tr');
                    tr.className = "border-b hover:bg-gray-50";
                    tr.innerHTML = `
                        <td class="py-2 px-4 truncate max-w-xs" title="${file.name}">${file.name}</td>
                        <td class="py-2 px-4 text-gray-500 italic">Pendiente de lectura</td>
                        <td class="py-2 px-4 text-yellow-600"><i class="fa-regular fa-clock"></i> Listo para procesar</td>
                    `;
                    tableBody.appendChild(tr);
                });

                document.getElementById('totalFilesCount').innerText = fileCount;
                
                if (fileCount > 0) {
                    document.getElementById('previewSection').classList.remove('hidden');
                    document.getElementById('processingSteps').classList.remove('hidden');
                    log("ZIP procesado exitosamente. Listo para Paso 1.", 'success');
                } else {
                    log("No se encontraron archivos .xls o .xlsx válidos en el ZIP.", 'error');
                }

            } catch (e) {
                log("Error leyendo el ZIP: " + e.message, 'error');
            }
        }

        // === STEP 1: CONSOLIDATE WORKBOOKS ===
        async function runStep1() {
            setLoading(1, true);
            log("Iniciando Paso 1: Unificando todos los libros...");
            
            // Allow UI to render loader
            await new Promise(r => setTimeout(r, 100));

            try {
                // Create a new master workbook
                const masterWb = XLSX.utils.book_new();
                const usedSheetNames = new Set();
                let filesProcessed = 0;
                let sheetsCopied = 0;

                for (const file of STATE.zipFiles) {
                    try {
                        // Read the excel file from buffer
                        const wb = XLSX.read(file.data, { type: 'array' });
                        
                        wb.SheetNames.forEach(sheetName => {
                            let ws = wb.Sheets[sheetName];
                            
                            // Handle duplicate names (Requerimiento: "conservando su nombre original (no se repiten y debe verificar que no lo hagan)")
                            let uniqueName = sheetName;
                            let counter = 1;
                            while (usedSheetNames.has(uniqueName)) {
                                uniqueName = `${sheetName}_${counter}`;
                                counter++;
                            }
                            usedSheetNames.add(uniqueName);

                            // Add to master workbook
                            XLSX.utils.book_append_sheet(masterWb, ws, uniqueName);
                            sheetsCopied++;
                        });
                        filesProcessed++;
                        // Log progress every 5 files to not spam
                        if (filesProcessed % 5 === 0) log(`Procesados ${filesProcessed}/${STATE.zipFiles.length} archivos...`);
                        
                    } catch (err) {
                        log(`Error leyendo ${file.name}: ${err.message}`, 'error');
                    }
                }

                STATE.wbStep1 = masterWb;
                
                log(`Paso 1 Completado. Libros: ${filesProcessed}, Hojas totales: ${sheetsCopied}`, 'success');
                setLoading(1, false);
                enableStep(2);
                document.getElementById('dlStep1').classList.remove('hidden');

            } catch (e) {
                log("Error crítico en Paso 1: " + e.message, 'error');
                setLoading(1, false);
            }
        }

        // === STEP 2: PRE-PROCESS SHEETS (THE NEW STEP 1.1) ===
        async function runStep2() {
            setLoading(2, true);
            log("Iniciando Paso 2: Pre-procesando hojas (limpieza y formato relacional)...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep1) throw new Error("Falta el resultado del Paso 1");

                // Create a new workbook for the results of this step
                const processedWb = XLSX.utils.book_new();
                let processedCount = 0;

                for (const sheetName of STATE.wbStep1.SheetNames) {
                    const ws = STATE.wbStep1.Sheets[sheetName];

                    if (sheetName.toLowerCase().startsWith('ramo')) {
                        // If sheet name starts with "Ramo", copy it as is
                        XLSX.utils.book_append_sheet(processedWb, ws, sheetName);
                        log(`Hoja '${sheetName}' omitida del pre-proceso (comienza con 'Ramo').`);
                        continue;
                    }

                    // Convert sheet to array of arrays
                    let data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null });

                    // 1. Delete first 3 rows
                    data.splice(0, 3);

                    // 2. Find metadata
                    let metadata = {
                        programa: '',
                        ramo: '',
                        unidad: '',
                        enfoque: '',
                        presupuestoOriginal: { meta: '', ejercido: '', pct: '' },
                        presupuestoModificado: { meta: '', ejercido: '', pct: '' }
                    };
                    let headerRowsToDelete = 0;

                    // 3. Find and delete "PRESUPUESTO" title row
                    const presupuestoTitleIndex = data.findIndex(row => 
                        String(row[0]).trim() === "PRESUPUESTO" && row.slice(1).every(c => c === null)
                    );
                    if (presupuestoTitleIndex > -1) {
                        data.splice(presupuestoTitleIndex, 1);
                    }

                    // 4. Extract data and find how many header rows to delete
                    let lastHeaderRowIndex = -1;
                    data.forEach((row, index) => {
                        const keyColA = String(row[0] || '').trim().replace(/\s+/g, ' '); // Clave principal en Columna A

                        if (keyColA.startsWith("Programa presupuestario")) { metadata.programa = row[3]; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Ramo")) { metadata.ramo = row[3]; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Unidad responsable")) { metadata.unidad = row[3]; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("Enfoques transversales")) { metadata.enfoque = row[3]; lastHeaderRowIndex = index; }
                        if (keyColA.startsWith("PRESUPUESTO ORIGINAL")) {
                            metadata.presupuestoOriginal = { meta: row[4] || '', ejercido: row[5] || '', pct: row[6] || '' };
                            lastHeaderRowIndex = index;
                        }
                        if (keyColA.startsWith("PRESUPUESTO MODIFICADO")) {
                            metadata.presupuestoModificado = { meta: row[4] || '', ejercido: row[5] || '', pct: row[6] || '' };
                            lastHeaderRowIndex = index;
                        }
                    });

                    // 5. Delete all header rows up to the last one found
                    if (lastHeaderRowIndex > -1) {
                        data.splice(0, lastHeaderRowIndex + 2); // +2 para eliminar también la fila de encabezados de la tabla
                    }

                    // 6. Add new headers and data
                    if (data.length > 0) {
                        // Add headers to the first row of data
                        const headers = [
                            "Programa Presupuestario", "Ramo", "Unidad Responsable", "Enfoque Transversal",
                            "PO Meta Anual", "PO Ejercido", "PO % Anual",
                            "PM Meta Anual", "PM Ejercido", "PM % Anual"
                        ];
                        headers.forEach((h, i) => data[0][10 + i] = h); // Start at column K (index 10)

                        // Add data to all subsequent rows
                        const values = [
                            metadata.programa, metadata.ramo, metadata.unidad, metadata.enfoque,
                            metadata.presupuestoOriginal.meta, metadata.presupuestoOriginal.ejercido, metadata.presupuestoOriginal.pct,
                            metadata.presupuestoModificado.meta, metadata.presupuestoModificado.ejercido, metadata.presupuestoModificado.pct
                        ];
                        for (let i = 1; i < data.length; i++) {
                            values.forEach((v, j) => data[i][10 + j] = v);
                        }
                    }

                    // Create a new worksheet with the transformed data
                    const newWs = XLSX.utils.aoa_to_sheet(data);
                    XLSX.utils.book_append_sheet(processedWb, newWs, sheetName);
                    processedCount++;
                }

                STATE.wbStep2 = processedWb;
                log(`Paso 2 Completado. Se pre-procesaron ${processedCount} hojas.`, 'success');
                setLoading(2, false);
                enableStep(3);
                document.getElementById('dlStep2').classList.remove('hidden');
            } catch (e) {
                log("Error en Paso 2: " + e.message, 'error');
                setLoading(2, false);
            }
        }

        // === STEP 3: CONSOLIDATE SHEETS (A:T + Label in U) ===
        async function runStep3() {
            setLoading(3, true);
            log("Iniciando Paso 3: Consolidando columnas A:T en una sola hoja...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep2) throw new Error("Falta el resultado del Paso 2");

                const sourceWb = STATE.wbStep2;
                const destWb = XLSX.utils.book_new(); // New workbook for result
                
                // Prepare Master Array
                // Header J1: NOMBRE_HOJA_ORIGEN
                let masterData = [];
                // Optional: Add headers if you want, but macro implies just data or keeps existing headers.
                // Replicating macro logic: The macro creates a destination sheet and starts pasting.
                // Let's simply iterate.
                
                const DEST_SHEET_NAME = "CONSOLIDADO_TOTAL";
                
                // Iterate all sheets in source
                sourceWb.SheetNames.forEach(sheetName => {
                    const ws = sourceWb.Sheets[sheetName];
                    
                    // Convert sheet to JSON array (array of arrays)
                    // header:1 gives us raw array of arrays
                    const data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
                    
                    if (data.length > 0) {
                        // Determine last row logic similar to macro
                        // JS array length is usually enough.
                        
                        data.forEach((row, rowIndex) => {
                            // We now want columns 0 to 19 (A to T)
                            let newRow = row.slice(0, 20);
                            
                            // Pad if row is shorter than 20 columns
                            while (newRow.length < 20) newRow.push("");
                            
                            // Add Sheet Name in Column U (Index 20)
                            newRow[20] = sheetName;
                            
                            masterData.push(newRow);
                        });
                    }
                });

                // Add Header for J if needed (Macro sets J1 bold "NOMBRE_HOJA_ORIGEN")
                // Since we merged everything, if the original sheets had headers, they are now rows in masterData.
                // If we strictly follow the macro, it copies everything.
                // Let's ensure J1 is the header.
                if (masterData.length > 0 && masterData[0]) {
                    masterData[0][20] = "NOMBRE_HOJA_ORIGEN"; 
                }

                // Create worksheet from data
                const newWs = XLSX.utils.aoa_to_sheet(masterData);
                
                // Add to workbook
                XLSX.utils.book_append_sheet(destWb, newWs, DEST_SHEET_NAME);
                
                STATE.wbStep3 = destWb;
                
                log(`Paso 3 Completado. ${masterData.length} filas generadas en ${DEST_SHEET_NAME}.`, 'success');
                setLoading(3, false);
                enableStep(4);
                document.getElementById('dlStep3').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 3: " + e.message, 'error');
                setLoading(3, false);
            }
        }

        // === STEP 4: UNMERGE ALL ===
        async function runStep4() {
            setLoading(4, true);
            log("Iniciando Paso 4: Descombinando celdas...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep3) throw new Error("Falta el resultado del Paso 3");
                
                // Clone workbook logic (SheetJS objects are references, so we should be careful)
                // Since we are moving forward, we can modify the previous WB or clone data.
                // Simplest: Write to buffer and read back to deep clone, or just modify the object if we don't care about history.
                // Let's modify object directly but save as new reference in state for clarity.
                
                const wb = STATE.wbStep3; // We will modify this directly effectively
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"];
                
                // Unmerge logic in SheetJS: simply delete the '!merges' property
                if (ws['!merges']) {
                    const count = ws['!merges'].length;
                    delete ws['!merges'];
                    log(`Se eliminaron ${count} configuraciones de fusión de celdas.`);
                } else {
                    log("No se encontraron celdas combinadas.");
                }

                STATE.wbStep4 = wb; // Pointer to same object (modified)
                
                log("Paso 4 Completado.", 'success');
                setLoading(4, false);
                enableStep(5);
                document.getElementById('dlStep4').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 4: " + e.message, 'error');
                setLoading(4, false);
            }
        }

        // === STEP 5: FILL BLANKS (Column A-F) ===
        async function runStep5() {
            setLoading(5, true);
            log("Iniciando Paso 5: Rellenando vacíos en Columnas A-F...");
            await new Promise(r => setTimeout(r, 100));

            try {
                if (!STATE.wbStep4) throw new Error("Falta el resultado del Paso 4");

                const wb = STATE.wbStep4;
                const ws = wb.Sheets["CONSOLIDADO_TOTAL"];
                
                // Get range
                const range = XLSX.utils.decode_range(ws['!ref']);
                const NUM_COLS_TO_FILL = 6; // A=0, B=1, C=2, D=3, E=4, F=5
                let lastValues = new Array(NUM_COLS_TO_FILL).fill(null);
                let filledCount = 0;

                // Loop through each row
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    // Loop through columns A to F
                    for (let C = 0; C < NUM_COLS_TO_FILL; ++C) {
                        const cellRef = XLSX.utils.encode_cell({c: C, r: R});
                        const cell = ws[cellRef];

                        // Check if cell is empty or has no value
                        if (!cell || cell.v === undefined || cell.v === "") {
                            // If it's empty but we have a last known value for this column, fill it
                            if (lastValues[C] !== null) {
                                ws[cellRef] = { v: lastValues[C], t: 's' }; // Use 's' for string type
                                filledCount++;
                            }
                        } else {
                            // If cell has a value, update the last known value for this column
                            lastValues[C] = cell.v;
                        }
                    }
                }

                // --- INICIO: Lógica agregada para filtrar y marcar "FID" ---
                log("Iniciando búsqueda de texto para marcar 'FID' en columna I...");
                const textoBusqueda = "Los Programas presupuestarios pueden ser ejecutados de manera conjunta por diversas Unidades Responsables para el cumplimiento de sus objetivos y metas. Para fines de recolección de la información del logro de los objetivos y metas establecidos en la Ficha de Indicadores del Desempeño (FID), en los reportes se asocia a una o más Unidades Responsables, que no necesariamente representan la totalidad de ellas. Por ello, para facilitar la identificación de las Unidades Responsables, se puede consultar el Estado Analítico del Ejercicio del Presupuesto de Egresos en Clasificación Funcional-Programática de cada Ramo en la Cuenta Pública 2024.";
                let fidCount = 0;

                // Recorrer filas nuevamente para buscar el texto en la columna A
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    const cellRefA = XLSX.utils.encode_cell({c: 0, r: R}); // Columna A
                    const cellA = ws[cellRefA];

                    // Normalizar el texto de la celda para una comparación robusta
                    const cellValue = (cellA && cellA.v) ? String(cellA.v).trim().replace(/\s+/g, ' ') : "";
                    const targetValue = textoBusqueda.replace(/\s+/g, ' ');

                    if (cellValue === targetValue) {
                        const cellRefI = XLSX.utils.encode_cell({c: 8, r: R}); // Columna I
                        
                        // Crear o actualizar la celda en la columna I
                        ws[cellRefI] = { v: "FID", t: 's' };
                        fidCount++;
                    }
                }

                if (fidCount > 0) {
                    log(`Se marcaron ${fidCount} filas con 'FID' en la columna I.`, 'success');
                }
                // --- FIN: Lógica agregada ---

                STATE.wbStep5 = wb;
                
                log(`Paso 5 Completado. Se rellenaron ${filledCount} celdas y se marcaron ${fidCount} filas como FID.`, 'success');
                setLoading(5, false);
                document.getElementById('dlStep5').classList.remove('hidden');

            } catch (e) {
                log("Error en Paso 5: " + e.message, 'error');
                setLoading(5, false);
            }
        }

        // === UTILS ===
        function enableStep(num) {
            const card = document.getElementById(`cardStep${num}`);
            card.classList.remove('disabled');
        }

        function setLoading(stepNum, isLoading) {
            const btn = document.querySelector(`#cardStep${stepNum} button`);
            if (isLoading) {
                btn.innerHTML = `<span class="loader border-t-white border-white/20 mr-2"></span> Procesando...`;
                btn.disabled = true;
                btn.classList.add('opacity-75');
            } else {
                btn.innerHTML = `<span>Re-ejecutar</span>`;
                btn.disabled = false;
                btn.classList.remove('opacity-75');
            }
        }

        function downloadStep(stepNum) {
            let wb = null;
            let filename = "";
            
            switch(stepNum) {
                case 1: 
                    wb = STATE.wbStep1; 
                    filename = "1_Libros_Unificados.xlsx"; 
                    break;
                case 2: 
                    wb = STATE.wbStep2; 
                    filename = "2_PreProcesado.xlsx"; 
                    break;
                case 3: 
                    wb = STATE.wbStep3; 
                    filename = "3_Hojas_Consolidadas.xlsx"; 
                    break;
                case 4: 
                    wb = STATE.wbStep4; 
                    filename = "4_Descombinado.xlsx"; 
                    break;
                case 5: 
                    wb = STATE.wbStep5; 
                    filename = "5_FINAL_Rellenado.xlsx"; 
                    break;
            }

            if (wb) {
                XLSX.writeFile(wb, filename);
            }
        }
    </script>
</body>
</html>
